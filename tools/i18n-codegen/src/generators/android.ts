/**
 * Android XML Generator
 *
 * Generates Android strings.xml files from translations.
 */

import * as path from 'path';
import type { AllTranslations, LocaleTranslations, SupportedLocale, TranslationEntry } from '../types';
import { LOCALE_MAPPINGS, SUPPORTED_LOCALES } from '../types';

interface AndroidGeneratorConfig {
  outputDir: string;
  generatePlurals: boolean;
}

/**
 * Convert i18next interpolation to Android format
 *
 * {{name}} → %s or %1$s (for multiple placeholders)
 * {name} → %s or %1$s
 *
 * Also escapes literal % characters to %% (Android format string requirement)
 */
function convertInterpolation(value: string): string {
  // First, escape any literal % to a placeholder marker
  // We'll convert it to %% after processing interpolations
  const PERCENT_PLACEHOLDER = '\u0000PERCENT\u0000';
  let result = value.replace(/%/g, PERCENT_PLACEHOLDER);

  const placeholders: string[] = [];

  // Find all placeholders
  const regex = /\{\{?(\w+)\}?\}/g;
  let match;
  while ((match = regex.exec(result)) !== null) {
    if (!placeholders.includes(match[1])) {
      placeholders.push(match[1]);
    }
  }

  // If only one placeholder, use simple %s
  // If multiple, use positional %1$s, %2$s, etc.
  if (placeholders.length <= 1) {
    result = result.replace(/\{\{?\w+\}?\}/g, '%s');
  } else {
    let placeholderIndex = 1;
    for (const placeholder of placeholders) {
      const pattern = new RegExp(`\\{\\{?${placeholder}\\}?\\}`, 'g');
      result = result.replace(pattern, `%${placeholderIndex}$s`);
      placeholderIndex++;
    }
  }

  // Convert escaped percent placeholders back to %%
  result = result.replace(new RegExp(PERCENT_PLACEHOLDER, 'g'), '%%');

  return result;
}

/**
 * Sanitize a key to be a valid Android resource name
 * Android resource names can only contain: a-z, A-Z, 0-9, underscore
 * Must start with a letter or underscore
 *
 * Only converts hyphens to underscores. Does NOT convert camelCase to snake_case
 * because that creates collisions between flat keys (priorityHigh) and
 * nested structures (priority.high) which both become priority_high.
 */
function sanitizeAndroidResourceName(key: string): string {
  // Replace hyphens with underscores
  return key.replace(/-/g, '_');
}

/**
 * Escape a string for Android XML
 */
function escapeAndroidString(value: string): string {
  return value
    // Escape apostrophes
    .replace(/'/g, "\\'")
    // Escape double quotes
    .replace(/"/g, '\\"')
    // Escape ampersand (must be done before other XML entities)
    .replace(/&(?!amp;|lt;|gt;|apos;|quot;)/g, '&amp;')
    // Escape less than
    .replace(/</g, '&lt;')
    // Escape greater than
    .replace(/>/g, '&gt;')
    // Escape newlines (Android uses \n literally in strings)
    .replace(/\n/g, '\\n');
}

/**
 * Get Android locale folder name
 */
function getAndroidLocaleFolder(locale: SupportedLocale): string {
  const mapped = LOCALE_MAPPINGS.android[locale];
  if (mapped) {
    return `values-${mapped}`;
  }
  if (locale === 'en') {
    return 'values';
  }
  return `values-${locale}`;
}

/**
 * Generate strings.xml content for a locale
 */
function generateStringsXml(
  translations: LocaleTranslations,
  config: AndroidGeneratorConfig
): string {
  const lines: string[] = [
    '<?xml version="1.0" encoding="utf-8"?>',
    '<!-- AUTO-GENERATED by i18n-codegen. DO NOT EDIT DIRECTLY. -->',
    '<resources>',
  ];

  // Group by namespace prefix for comments
  let currentNamespace = '';

  // Sort entries by key for consistent output
  const sortedEntries = [...translations.entries()].sort((a, b) =>
    a[0].localeCompare(b[0])
  );

  const plurals: TranslationEntry[] = [];
  const strings: TranslationEntry[] = [];

  // Separate plurals from regular strings
  for (const [, entry] of sortedEntries) {
    if (entry.isPlural && entry.pluralForms) {
      plurals.push(entry);
    } else {
      strings.push(entry);
    }
  }

  // Generate regular strings
  for (const entry of strings) {
    // Add namespace comment
    const keyParts = entry.key.split('_');
    const namespace = keyParts[0];
    if (namespace !== currentNamespace) {
      currentNamespace = namespace;
      lines.push('');
      lines.push(`    <!-- ${capitalize(namespace)} -->`);
    }

    const androidValue = escapeAndroidString(convertInterpolation(entry.value));
    const androidKey = sanitizeAndroidResourceName(entry.key);
    lines.push(`    <string name="${androidKey}">${androidValue}</string>`);
  }

  // Generate plurals if enabled
  if (config.generatePlurals && plurals.length > 0) {
    lines.push('');
    lines.push('    <!-- Plurals -->');

    for (const entry of plurals) {
      if (!entry.pluralForms) continue;

      const androidKey = sanitizeAndroidResourceName(entry.key);
      lines.push(`    <plurals name="${androidKey}">`);
      for (const [form, value] of Object.entries(entry.pluralForms)) {
        const androidForm = mapPluralForm(form);
        if (androidForm) {
          const androidValue = escapeAndroidString(convertInterpolation(value));
          lines.push(`        <item quantity="${androidForm}">${androidValue}</item>`);
        }
      }
      lines.push('    </plurals>');
    }
  }

  lines.push('</resources>');
  lines.push('');

  return lines.join('\n');
}

/**
 * Map i18n plural forms to Android quantity strings
 */
function mapPluralForm(form: string): string | null {
  const mapping: Record<string, string> = {
    zero: 'zero',
    one: 'one',
    two: 'two',
    few: 'few',
    many: 'many',
    other: 'other',
  };
  return mapping[form] || null;
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Generate all Android strings.xml files
 */
export async function generateAndroidStrings(
  allTranslations: AllTranslations,
  config: AndroidGeneratorConfig
): Promise<void> {
  const { outputDir } = config;

  for (const locale of SUPPORTED_LOCALES) {
    const translations = allTranslations.get(locale);
    if (!translations || translations.size === 0) {
      console.log(`  [android] ${locale}: skipped (no translations)`);
      continue;
    }

    const folder = getAndroidLocaleFolder(locale);
    const filePath = path.join(outputDir, folder, 'strings.xml');

    const content = generateStringsXml(translations, config);

    // Ensure directory exists
    const dir = path.dirname(filePath);
    await Bun.write(filePath, content);

    console.log(`  [android] ${locale}: ${translations.size} keys → ${folder}/strings.xml`);
  }
}

/**
 * Generate type-safe Kotlin accessors (optional)
 */
export async function generateKotlinAccessors(
  translations: LocaleTranslations,
  outputPath: string,
  packageName: string
): Promise<void> {
  const lines: string[] = [
    '// AUTO-GENERATED by i18n-codegen. DO NOT EDIT DIRECTLY.',
    '',
    `package ${packageName}`,
    '',
    'import android.content.Context',
    'import androidx.compose.runtime.Composable',
    'import androidx.compose.ui.res.stringResource',
    '',
    '/**',
    ' * Type-safe string resource accessors',
    ' */',
    'object L10n {',
  ];

  // Group by namespace
  const namespaces = new Map<string, TranslationEntry[]>();
  for (const [, entry] of translations) {
    const parts = entry.key.split('_');
    const namespace = parts[0];
    if (!namespaces.has(namespace)) {
      namespaces.set(namespace, []);
    }
    namespaces.get(namespace)!.push(entry);
  }

  for (const [namespace, entries] of namespaces) {
    lines.push('');
    lines.push(`    object ${capitalize(namespace)} {`);

    for (const entry of entries) {
      const parts = entry.key.split('_');
      const propName = parts.slice(1).map((p, i) =>
        i === 0 ? p : capitalize(p)
      ).join('');

      const androidKey = sanitizeAndroidResourceName(entry.key);
      if (entry.value.includes('{{') || entry.value.includes('{')) {
        // Function for interpolated strings
        lines.push(`        @Composable`);
        lines.push(`        fun ${propName}(vararg args: Any): String =`);
        lines.push(`            stringResource(R.string.${androidKey}, *args)`);
      } else {
        // Property for simple strings
        lines.push(`        val ${propName}: String`);
        lines.push(`            @Composable get() = stringResource(R.string.${androidKey})`);
      }
    }

    lines.push('    }');
  }

  lines.push('}');
  lines.push('');

  await Bun.write(outputPath, lines.join('\n'));
}
