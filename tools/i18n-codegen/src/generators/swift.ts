/**
 * Swift Type-Safe Accessor Generator
 *
 * Generates L10n.swift with type-safe string accessors for SwiftUI.
 */

import type { LocaleTranslations, TranslationEntry } from '../types';

interface SwiftGeneratorConfig {
  outputPath: string;
  enumName: string;
}

/**
 * Check if a string has interpolation placeholders
 */
function hasPlaceholders(value: string): boolean {
  return /\{\{?\w+\}?\}/.test(value);
}

/**
 * Extract placeholder types from a string
 * Returns an array of parameter types (String or Int)
 */
function extractPlaceholderTypes(value: string): Array<{ name: string; type: 'String' | 'Int' }> {
  const placeholders: Array<{ name: string; type: 'String' | 'Int' }> = [];
  const regex = /\{\{?(\w+)\}?\}/g;
  let match;

  while ((match = regex.exec(value)) !== null) {
    const name = match[1];
    if (!placeholders.find((p) => p.name === name)) {
      // Determine type based on name
      const isNumber =
        name === 'count' ||
        name === 'number' ||
        name === 'n' ||
        name.endsWith('Count') ||
        name.endsWith('Number');

      placeholders.push({
        name,
        type: isNumber ? 'Int' : 'String',
      });
    }
  }

  return placeholders;
}

/**
 * Convert a key to a valid Swift identifier
 */
function toSwiftIdentifier(key: string): string {
  // Remove namespace prefix for property name
  const parts = key.split('_');
  if (parts.length === 1) return parts[0];

  // camelCase the rest
  return parts
    .slice(1)
    .map((part, index) => (index === 0 ? part : capitalize(part)))
    .join('');
}

/**
 * Convert a namespace to a valid Swift enum name
 */
function toSwiftEnumName(namespace: string): string {
  return capitalize(namespace.replace(/-/g, ''));
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Generate L10n.swift content
 */
export function generateSwiftAccessors(
  translations: LocaleTranslations,
  config: SwiftGeneratorConfig
): string {
  const { enumName } = config;

  const lines: string[] = [
    '// AUTO-GENERATED by i18n-codegen. DO NOT EDIT DIRECTLY.',
    '//',
    '// Type-safe localization accessors for SwiftUI',
    '',
    'import Foundation',
    'import SwiftUI',
    '',
    '// MARK: - L10n',
    '',
    `/// Type-safe localization accessors`,
    `public enum ${enumName} {`,
  ];

  // Group by namespace
  const namespaces = new Map<string, TranslationEntry[]>();
  for (const [, entry] of translations) {
    if (entry.isPlural) continue; // Handle plurals separately

    const parts = entry.key.split('_');
    const namespace = parts[0];
    if (!namespaces.has(namespace)) {
      namespaces.set(namespace, []);
    }
    namespaces.get(namespace)!.push(entry);
  }

  // Generate nested enums for each namespace
  for (const [namespace, entries] of namespaces) {
    const enumName = toSwiftEnumName(namespace);

    lines.push('');
    lines.push(`    /// ${capitalize(namespace)} translations`);
    lines.push(`    public enum ${enumName} {`);

    for (const entry of entries) {
      const propName = toSwiftIdentifier(entry.key);

      if (hasPlaceholders(entry.value)) {
        // Function for interpolated strings
        const placeholders = extractPlaceholderTypes(entry.value);
        const params = placeholders
          .map((p) => `_ ${p.name}: ${p.type}`)
          .join(', ');
        const args = placeholders.map((p) => p.name).join(', ');

        lines.push('');
        lines.push(`        /// ${escapeDocComment(entry.value)}`);
        lines.push(`        public static func ${propName}(${params}) -> String {`);
        lines.push(`            String(format: NSLocalizedString("${entry.key}", comment: ""), ${args})`);
        lines.push('        }');
      } else {
        // Static property for simple strings
        lines.push('');
        lines.push(`        /// ${escapeDocComment(entry.value)}`);
        lines.push(`        public static var ${propName}: String {`);
        lines.push(`            NSLocalizedString("${entry.key}", comment: "")`);
        lines.push('        }');
      }
    }

    lines.push('    }');
  }

  // Generate plural accessors
  const pluralEntries = [...translations.entries()].filter(([, e]) => e.isPlural);
  if (pluralEntries.length > 0) {
    lines.push('');
    lines.push('    // MARK: - Plurals');
    lines.push('');
    lines.push('    /// Plural translations');
    lines.push('    public enum Plurals {');

    for (const [key, entry] of pluralEntries) {
      const parts = key.split('_');
      const funcName = parts.slice(1).map((p, i) => (i === 0 ? p : capitalize(p))).join('');

      lines.push('');
      lines.push(`        /// ${escapeDocComment(entry.pluralForms?.other || entry.value)}`);
      lines.push(`        public static func ${funcName}(_ count: Int) -> String {`);
      lines.push(`            String.localizedStringWithFormat(`);
      lines.push(`                NSLocalizedString("${key}", comment: ""),`);
      lines.push(`                count`);
      lines.push('            )');
      lines.push('        }');
    }

    lines.push('    }');
  }

  lines.push('}');
  lines.push('');

  // Add String extension for convenience
  lines.push('// MARK: - String Extension');
  lines.push('');
  lines.push('public extension String {');
  lines.push('    /// Localize a string key');
  lines.push('    var localized: String {');
  lines.push('        NSLocalizedString(self, comment: "")');
  lines.push('    }');
  lines.push('');
  lines.push('    /// Localize a string key with arguments');
  lines.push('    func localized(_ args: CVarArg...) -> String {');
  lines.push('        String(format: NSLocalizedString(self, comment: ""), arguments: args)');
  lines.push('    }');
  lines.push('}');
  lines.push('');

  // Add LocalizedStringKey extension for SwiftUI
  lines.push('// MARK: - LocalizedStringKey Extension');
  lines.push('');
  lines.push('public extension LocalizedStringKey {');
  lines.push('    /// Initialize from a translation key');
  lines.push('    init(_ key: String, comment: String = "") {');
  lines.push('        self.init(stringLiteral: NSLocalizedString(key, comment: comment))');
  lines.push('    }');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Escape a string for use in Swift documentation comment
 */
function escapeDocComment(value: string): string {
  return value
    .replace(/\n/g, ' ')
    .replace(/\*/g, '\\*')
    .replace(/\//g, '\\/')
    .substring(0, 100)
    .trim();
}

/**
 * Write Swift accessor file
 */
export async function writeSwiftAccessors(
  translations: LocaleTranslations,
  config: SwiftGeneratorConfig
): Promise<void> {
  const content = generateSwiftAccessors(translations, config);
  await Bun.write(config.outputPath, content);
  console.log(`  [swift] Generated L10n.swift with ${translations.size} keys`);
}
