/**
 * iOS Strings Generator
 *
 * Generates iOS Localizable.strings and Localizable.stringsdict files.
 */

import * as path from 'path';
import type { AllTranslations, LocaleTranslations, SupportedLocale, TranslationEntry } from '../types';
import { LOCALE_MAPPINGS, SUPPORTED_LOCALES } from '../types';

interface IOSGeneratorConfig {
  outputDir: string;
  generatePlurals: boolean;
}

/**
 * Convert i18next interpolation to iOS format
 *
 * {{name}} → %@ (for strings) or positional %1$@
 * {{count}} → %lld (for integers)
 */
function convertInterpolation(value: string): string {
  let placeholderIndex = 1;
  const placeholders: { name: string; index: number }[] = [];

  // Find all placeholders
  const regex = /\{\{?(\w+)\}?\}/g;
  let match;
  while ((match = regex.exec(value)) !== null) {
    const existing = placeholders.find((p) => p.name === match[1]);
    if (!existing) {
      placeholders.push({ name: match[1], index: placeholderIndex++ });
    }
  }

  // If only one placeholder and it's a count, use %lld
  // Otherwise use %@ for strings
  if (placeholders.length === 1) {
    const placeholder = placeholders[0];
    if (placeholder.name === 'count' || placeholder.name === 'number' || placeholder.name === 'n') {
      return value.replace(/\{\{?\w+\}?\}/g, '%lld');
    }
    return value.replace(/\{\{?\w+\}?\}/g, '%@');
  }

  // Multiple placeholders - use positional
  let result = value;
  for (const placeholder of placeholders) {
    const pattern = new RegExp(`\\{\\{?${placeholder.name}\\}?\\}`, 'g');
    if (placeholder.name === 'count' || placeholder.name === 'number' || placeholder.name === 'n') {
      result = result.replace(pattern, `%${placeholder.index}$lld`);
    } else {
      result = result.replace(pattern, `%${placeholder.index}$@`);
    }
  }

  return result;
}

/**
 * Escape a string for iOS .strings file
 */
function escapeIOSString(value: string): string {
  return value
    // Escape backslashes first
    .replace(/\\/g, '\\\\')
    // Escape double quotes
    .replace(/"/g, '\\"')
    // Escape newlines
    .replace(/\n/g, '\\n')
    // Escape tabs
    .replace(/\t/g, '\\t');
}

/**
 * Get iOS locale folder name
 */
function getIOSLocaleFolder(locale: SupportedLocale): string {
  const mapped = LOCALE_MAPPINGS.ios[locale];
  return `${mapped || locale}.lproj`;
}

/**
 * Generate Localizable.strings content for a locale
 */
function generateStringsFile(translations: LocaleTranslations): string {
  const lines: string[] = [
    '/* AUTO-GENERATED by i18n-codegen. DO NOT EDIT DIRECTLY. */',
    '',
  ];

  // Group by namespace for comments
  let currentNamespace = '';

  // Sort entries by key
  const sortedEntries = [...translations.entries()]
    .filter(([, entry]) => !entry.isPlural)
    .sort((a, b) => a[0].localeCompare(b[0]));

  for (const [, entry] of sortedEntries) {
    // Add namespace comment
    const keyParts = entry.key.split('_');
    const namespace = keyParts[0];
    if (namespace !== currentNamespace) {
      currentNamespace = namespace;
      lines.push('');
      lines.push(`/* ${capitalize(namespace)} */`);
    }

    const iosValue = escapeIOSString(convertInterpolation(entry.value));
    lines.push(`"${entry.key}" = "${iosValue}";`);
  }

  lines.push('');

  return lines.join('\n');
}

/**
 * Generate Localizable.stringsdict content for plurals
 */
function generateStringsDictFile(
  translations: LocaleTranslations,
  locale: SupportedLocale
): string | null {
  const pluralEntries = [...translations.entries()].filter(([, entry]) => entry.isPlural);

  if (pluralEntries.length === 0) {
    return null;
  }

  const lines: string[] = [
    '<?xml version="1.0" encoding="UTF-8"?>',
    '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">',
    '<!-- AUTO-GENERATED by i18n-codegen. DO NOT EDIT DIRECTLY. -->',
    '<plist version="1.0">',
    '<dict>',
  ];

  for (const [key, entry] of pluralEntries) {
    if (!entry.pluralForms) continue;

    lines.push(`    <key>${key}</key>`);
    lines.push('    <dict>');
    lines.push('        <key>NSStringLocalizedFormatKey</key>');
    lines.push('        <string>%#@count@</string>');
    lines.push('        <key>count</key>');
    lines.push('        <dict>');
    lines.push('            <key>NSStringFormatSpecTypeKey</key>');
    lines.push('            <string>NSStringPluralRuleType</string>');
    lines.push('            <key>NSStringFormatValueTypeKey</key>');
    lines.push('            <string>lld</string>');

    for (const [form, value] of Object.entries(entry.pluralForms)) {
      const iosForm = mapPluralForm(form);
      if (iosForm) {
        const iosValue = escapeIOSString(convertInterpolation(value));
        lines.push(`            <key>${iosForm}</key>`);
        lines.push(`            <string>${iosValue}</string>`);
      }
    }

    lines.push('        </dict>');
    lines.push('    </dict>');
  }

  lines.push('</dict>');
  lines.push('</plist>');
  lines.push('');

  return lines.join('\n');
}

/**
 * Map i18n plural forms to iOS plural rules
 */
function mapPluralForm(form: string): string | null {
  const mapping: Record<string, string> = {
    zero: 'zero',
    one: 'one',
    two: 'two',
    few: 'few',
    many: 'many',
    other: 'other',
  };
  return mapping[form] || null;
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Generate all iOS strings files
 */
export async function generateIOSStrings(
  allTranslations: AllTranslations,
  config: IOSGeneratorConfig
): Promise<void> {
  const { outputDir, generatePlurals } = config;

  for (const locale of SUPPORTED_LOCALES) {
    const translations = allTranslations.get(locale);
    if (!translations || translations.size === 0) {
      console.log(`  [ios] ${locale}: skipped (no translations)`);
      continue;
    }

    const folder = getIOSLocaleFolder(locale);
    const folderPath = path.join(outputDir, folder);

    // Generate Localizable.strings
    const stringsContent = generateStringsFile(translations);
    const stringsPath = path.join(folderPath, 'Localizable.strings');
    await Bun.write(stringsPath, stringsContent);

    // Generate Localizable.stringsdict for plurals
    if (generatePlurals) {
      const dictContent = generateStringsDictFile(translations, locale);
      if (dictContent) {
        const dictPath = path.join(folderPath, 'Localizable.stringsdict');
        await Bun.write(dictPath, dictContent);
      }
    }

    const pluralCount = [...translations.values()].filter((e) => e.isPlural).length;
    const stringCount = translations.size - pluralCount;
    console.log(`  [ios] ${locale}: ${stringCount} strings, ${pluralCount} plurals → ${folder}/`);
  }
}
