/**
 * Zod Validation Schema Generator
 *
 * Generates Zod validation schemas from JSON Schema $defs.
 * Maps JSON Schema types and constraints to Zod validators.
 *
 * Output for each module:
 *   - Zod schemas for each $defs type
 *   - Inferred TypeScript types from Zod schemas
 */

import type {
  ModuleSchema,
  JsonSchemaDef,
  JsonSchemaProperty,
} from '../utils/json-schema';
import { pascalCase, constCase, resolveRefName } from '../utils/json-schema';

/**
 * Generate Zod validation schemas for a module.
 */
export function generateZodSchemas(moduleName: string, schema: ModuleSchema): string | null {
  const defs = schema.$defs;
  if (!defs || Object.keys(defs).length === 0) {
    return null;
  }

  const version = schema.version || '1.0.0';
  const pascal = pascalCase(moduleName);
  const moduleConst = constCase(moduleName);

  // Topological sort: generate types that are referenced before types that reference them
  const sorted = topologicalSort(defs);

  let code = `/**
 * @generated from protocol/schemas/modules/${moduleName}/v${version.split('.')[0]}.json
 * @version ${version}
 *
 * DO NOT EDIT - This file is auto-generated by tools/codegen
 * Zod validation schemas for the ${pascal} module
 */

import { z } from 'zod';

`;

  // Generate enum schemas first (they're leaf nodes)
  const enumTypes: Set<string> = new Set();
  for (const name of sorted) {
    const def = defs[name];
    if (def.enum && def.type === 'string') {
      enumTypes.add(name);
      code += generateEnumSchema(name, def);
    }
  }

  // Generate object schemas
  for (const name of sorted) {
    if (enumTypes.has(name)) continue;
    const def = defs[name];
    if (def.type === 'object') {
      code += generateObjectSchema(name, def, defs, enumTypes);
    }
  }

  // Export version constant
  code += `\n/** Module version */\n`;
  code += `export const ${moduleConst}_SCHEMA_VERSION = '${version}' as const;\n`;

  return code;
}

function generateEnumSchema(name: string, def: JsonSchemaDef): string {
  const values = def.enum || [];
  const schemaName = `${name}Schema`;
  const valuesStr = values.map((v) => `'${v}'`).join(', ');

  let code = '';
  if (def.description) {
    code += `/** ${def.description} */\n`;
  }
  code += `export const ${schemaName} = z.enum([${valuesStr}]);\n`;
  code += `export type ${name} = z.infer<typeof ${schemaName}>;\n\n`;

  return code;
}

function generateObjectSchema(
  name: string,
  def: JsonSchemaDef,
  allDefs: Record<string, JsonSchemaDef>,
  enumTypes: Set<string>
): string {
  const properties = def.properties || {};
  const required = new Set(def.required || []);
  const schemaName = `${name}Schema`;

  let code = '';
  if (def.description) {
    code += `/** ${def.description} */\n`;
  }
  code += `export const ${schemaName} = z.object({\n`;

  for (const [propName, propDef] of Object.entries(properties)) {
    let zodType = jsonSchemaToZod(propDef, allDefs, enumTypes);

    // Handle default values
    if (propDef.default !== undefined && !required.has(propName)) {
      const defaultVal = formatDefault(propDef.default);
      if (defaultVal !== null) {
        zodType += `.default(${defaultVal})`;
      }
    }

    // Make optional if not required
    if (!required.has(propName) && propDef.default === undefined) {
      zodType += '.optional()';
    }

    if (propDef.description) {
      code += `  /** ${propDef.description} */\n`;
    }
    code += `  ${propName}: ${zodType},\n`;
  }

  code += `})`;

  // Add passthrough for additionalProperties: true
  if (def.additionalProperties === true) {
    code += `.passthrough()`;
  }

  code += `;\n`;
  code += `export type ${name} = z.infer<typeof ${schemaName}>;\n\n`;

  return code;
}

function jsonSchemaToZod(
  prop: JsonSchemaProperty,
  defs: Record<string, JsonSchemaDef>,
  enumTypes: Set<string>
): string {
  // Handle $ref
  if (prop.$ref) {
    const refName = resolveRefName(prop.$ref);
    if (refName) {
      if (enumTypes.has(refName)) {
        return `${refName}Schema`;
      }
      if (defs[refName]?.type === 'object') {
        return `${refName}Schema`;
      }
      if (defs[refName]?.enum) {
        return `${refName}Schema`;
      }
      // Fallback: generate inline from the referenced def
      if (defs[refName]) {
        return jsonSchemaToZod(defs[refName], defs, enumTypes);
      }
    }
    return 'z.unknown()';
  }

  // Handle enum
  if (prop.enum) {
    const values = prop.enum.map((v) => `'${v}'`).join(', ');
    return `z.enum([${values}])`;
  }

  // Handle oneOf
  if (prop.oneOf) {
    const branches = prop.oneOf.map((o) => jsonSchemaToZod(o, defs, enumTypes));
    if (branches.length === 2) {
      return `z.union([${branches.join(', ')}])`;
    }
    return `z.union([${branches.join(', ')}])`;
  }

  // Handle array
  if (prop.type === 'array') {
    let itemZod = 'z.unknown()';
    if (prop.items) {
      itemZod = jsonSchemaToZod(prop.items, defs, enumTypes);
    }
    let arrSchema = `z.array(${itemZod})`;
    if (prop.maxItems !== undefined) {
      arrSchema += `.max(${prop.maxItems})`;
    }
    if (prop.minItems !== undefined) {
      arrSchema += `.min(${prop.minItems})`;
    }
    return arrSchema;
  }

  // Handle object without properties (record)
  if (prop.type === 'object' && !prop.properties) {
    if (prop.additionalProperties && typeof prop.additionalProperties === 'object') {
      const valZod = jsonSchemaToZod(prop.additionalProperties as JsonSchemaProperty, defs, enumTypes);
      return `z.record(z.string(), ${valZod})`;
    }
    return 'z.record(z.string(), z.unknown())';
  }

  // Handle inline object with properties
  if (prop.type === 'object' && prop.properties) {
    const req = new Set(prop.required || []);
    const fields = Object.entries(prop.properties).map(([k, v]) => {
      let fieldZod = jsonSchemaToZod(v, defs, enumTypes);
      if (!req.has(k)) {
        fieldZod += '.optional()';
      }
      return `${k}: ${fieldZod}`;
    });
    return `z.object({ ${fields.join(', ')} })`;
  }

  // Handle string with constraints
  if (prop.type === 'string') {
    let s = 'z.string()';
    if (prop.format === 'uuid') s += '.uuid()';
    else if (prop.format === 'email') s += '.email()';
    else if (prop.format === 'uri') s += '.url()';
    if (prop.pattern && prop.format !== 'uuid') {
      // Escape backticks and backslashes for template literal
      const escapedPattern = prop.pattern.replace(/\\/g, '\\\\').replace(/`/g, '\\`');
      s += `.regex(new RegExp(\`${escapedPattern}\`))`;
    }
    if (prop.minLength !== undefined) s += `.min(${prop.minLength})`;
    if (prop.maxLength !== undefined) s += `.max(${prop.maxLength})`;
    return s;
  }

  // Handle integer
  if (prop.type === 'integer') {
    let s = 'z.number().int()';
    if (prop.minimum !== undefined) s += `.min(${prop.minimum})`;
    if (prop.maximum !== undefined) s += `.max(${prop.maximum})`;
    return s;
  }

  // Handle number
  if (prop.type === 'number') {
    let s = 'z.number()';
    if (prop.minimum !== undefined) s += `.min(${prop.minimum})`;
    if (prop.maximum !== undefined) s += `.max(${prop.maximum})`;
    return s;
  }

  // Handle boolean
  if (prop.type === 'boolean') {
    return 'z.boolean()';
  }

  return 'z.unknown()';
}

function formatDefault(value: unknown): string | null {
  if (typeof value === 'string') return `'${value}'`;
  if (typeof value === 'number') return String(value);
  if (typeof value === 'boolean') return String(value);
  if (value === null) return 'null';
  if (Array.isArray(value) && value.length === 0) return '[]';
  return null;
}

/**
 * Topological sort of $defs based on $ref dependencies.
 * Types that are referenced come before types that reference them.
 */
function topologicalSort(defs: Record<string, JsonSchemaDef>): string[] {
  const names = Object.keys(defs);
  const visited = new Set<string>();
  const result: string[] = [];

  function getDeps(def: JsonSchemaDef): string[] {
    const deps: string[] = [];
    const walk = (obj: unknown) => {
      if (!obj || typeof obj !== 'object') return;
      const record = obj as Record<string, unknown>;
      if (record.$ref && typeof record.$ref === 'string') {
        const name = resolveRefName(record.$ref as string);
        if (name && names.includes(name)) {
          deps.push(name);
        }
      }
      for (const val of Object.values(record)) {
        if (Array.isArray(val)) {
          val.forEach(walk);
        } else if (typeof val === 'object' && val !== null) {
          walk(val);
        }
      }
    };
    walk(def);
    return deps;
  }

  function visit(name: string) {
    if (visited.has(name)) return;
    visited.add(name);
    for (const dep of getDeps(defs[name])) {
      visit(dep);
    }
    result.push(name);
  }

  for (const name of names) {
    visit(name);
  }

  return result;
}
