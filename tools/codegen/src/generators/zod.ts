/**
 * Zod Validation Schema Generator
 *
 * Generates Zod validation schemas from JSON Schema $defs.
 * Uses json-schema-to-zod library for type/constraint mapping,
 * with custom orchestration for $ref resolution, formatting,
 * and module-level code generation.
 *
 * Output for each module:
 *   - Zod schemas for each $defs type
 *   - Inferred TypeScript types from Zod schemas
 */

import { jsonSchemaToZod } from 'json-schema-to-zod';
import type { ParserOverride, JsonSchemaObject } from 'json-schema-to-zod';
import type {
  ModuleSchema,
  JsonSchemaDef,
} from '../utils/json-schema';
import { pascalCase, constCase, resolveRefName } from '../utils/json-schema';

/**
 * Create a parserOverride that resolves $ref to already-generated schema names
 * and converts oneOf to z.union() instead of the library's verbose superRefine.
 */
function createParserOverride(defNames: Set<string>): ParserOverride {
  const override: ParserOverride = (schema: JsonSchemaObject) => {
    // Intercept $ref → return "XyzSchema" reference
    if (schema.$ref) {
      const refName = resolveRefName(schema.$ref as string);
      if (refName && defNames.has(refName)) {
        return `${refName}Schema`;
      }
      return 'z.unknown()';
    }

    // Intercept oneOf → z.union() instead of verbose superRefine
    if (schema.oneOf && Array.isArray(schema.oneOf)) {
      const branches = schema.oneOf.map((branch) => {
        if (typeof branch === 'boolean') return 'z.any()';
        return jsonSchemaToZod(branch, {
          module: 'none',
          noImport: true,
          parserOverride: override,
        });
      });
      return `z.union([${branches.join(', ')}])`;
    }
  };
  return override;
}

/**
 * Convert a single property schema to a Zod type string using the library.
 */
function propertyToZod(
  prop: JsonSchemaDef,
  parserOverride: ParserOverride,
): string {
  return jsonSchemaToZod(prop as JsonSchemaObject, {
    module: 'none',
    noImport: true,
    parserOverride,
  });
}

/**
 * Generate Zod validation schemas for a module.
 */
export function generateZodSchemas(moduleName: string, schema: ModuleSchema): string | null {
  const defs = schema.$defs;
  if (!defs || Object.keys(defs).length === 0) {
    return null;
  }

  const version = schema.version || '1.0.0';
  const pascal = pascalCase(moduleName);
  const moduleConst = constCase(moduleName);

  // Topological sort: generate types that are referenced before types that reference them
  const sorted = topologicalSort(defs);
  const defNames = new Set(sorted);
  const parserOverride = createParserOverride(defNames);

  let code = `/**
 * @generated from protocol/schemas/modules/${moduleName}/v${version.split('.')[0]}.json
 * @version ${version}
 *
 * DO NOT EDIT - This file is auto-generated by tools/codegen
 * Zod validation schemas for the ${pascal} module
 */

import { z } from 'zod';

`;

  // Generate enum schemas first (they're leaf nodes)
  const enumTypes: Set<string> = new Set();
  for (const name of sorted) {
    const def = defs[name];
    if (def.enum && def.type === 'string') {
      enumTypes.add(name);
      code += generateEnumSchema(name, def, parserOverride);
    }
  }

  // Generate union-only schemas (oneOf without type, e.g., FacetValue, SearchScope)
  const unionTypes: Set<string> = new Set();
  for (const name of sorted) {
    if (enumTypes.has(name)) continue;
    const def = defs[name];
    if (!def.type && def.oneOf) {
      unionTypes.add(name);
      code += generateUnionSchema(name, def, parserOverride);
    }
  }

  // Generate object schemas
  for (const name of sorted) {
    if (enumTypes.has(name) || unionTypes.has(name)) continue;
    const def = defs[name];
    if (def.type === 'object') {
      code += generateObjectSchema(name, def, parserOverride);
    }
  }

  // Export version constant
  code += `\n/** Module version */\n`;
  code += `export const ${moduleConst}_SCHEMA_VERSION = '${version}' as const;\n`;

  return code;
}

/**
 * Generate a Zod enum schema using the library.
 */
function generateEnumSchema(
  name: string,
  def: JsonSchemaDef,
  parserOverride: ParserOverride,
): string {
  const schemaName = `${name}Schema`;

  // Use the library to generate the enum expression
  let zodExpr = propertyToZod(def, parserOverride);

  // Strip .describe() — we use JSDoc comments for descriptions
  zodExpr = stripDescribe(zodExpr);

  let code = '';
  if (def.description) {
    code += `/** ${def.description} */\n`;
  }
  code += `export const ${schemaName} = ${zodExpr};\n`;
  code += `export type ${name} = z.infer<typeof ${schemaName}>;\n\n`;

  return code;
}

/**
 * Generate a Zod union schema for oneOf-only $defs (no type property).
 */
function generateUnionSchema(
  name: string,
  def: JsonSchemaDef,
  parserOverride: ParserOverride,
): string {
  const schemaName = `${name}Schema`;

  // Use the library via our parserOverride which converts oneOf → z.union()
  let zodExpr = propertyToZod(def, parserOverride);
  zodExpr = stripDescribe(zodExpr);
  zodExpr = fixRecordArgs(zodExpr);

  let code = '';
  if (def.description) {
    code += `/** ${def.description} */\n`;
  }
  code += `export const ${schemaName} = ${zodExpr};\n`;
  code += `export type ${name} = z.infer<typeof ${schemaName}>;\n\n`;

  return code;
}

/**
 * Generate a Zod object schema with per-property library conversion.
 * Keeps our formatting (one property per line with JSDoc comments)
 * while delegating type conversion to json-schema-to-zod.
 */
function generateObjectSchema(
  name: string,
  def: JsonSchemaDef,
  parserOverride: ParserOverride,
): string {
  const properties = def.properties || {};
  const required = new Set(def.required || []);
  const schemaName = `${name}Schema`;

  let code = '';
  if (def.description) {
    code += `/** ${def.description} */\n`;
  }
  code += `export const ${schemaName} = z.object({\n`;

  for (const [propName, propDef] of Object.entries(properties)) {
    // Use the library for type conversion (handles constraints, formats, patterns, etc.)
    let zodType = propertyToZod(propDef, parserOverride);

    // Strip .describe() from the library output — we use JSDoc comments instead
    zodType = stripDescribe(zodType);

    // Fix z.record() calls to use 2-arg form for Zod 4 compatibility
    zodType = fixRecordArgs(zodType);

    // Handle optional/default for non-required fields
    // The library already adds .default() when the schema has a default value,
    // so we only add .optional() for non-required fields without defaults.
    if (!required.has(propName) && propDef.default === undefined) {
      zodType += '.optional()';
    }

    if (propDef.description) {
      code += `  /** ${propDef.description} */\n`;
    }
    code += `  ${propName}: ${zodType},\n`;
  }

  code += `})`;

  // Add passthrough for additionalProperties: true
  if (def.additionalProperties === true) {
    code += `.passthrough()`;
  }

  code += `;\n`;
  code += `export type ${name} = z.infer<typeof ${schemaName}>;\n\n`;

  return code;
}

/**
 * Strip .describe("...") calls from a Zod expression string.
 * We use JSDoc comments for descriptions instead.
 */
function stripDescribe(zodExpr: string): string {
  // Match .describe("...") or .describe('...') — handles escaped quotes
  return zodExpr.replace(/\.describe\((?:"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')\)/g, '');
}

/**
 * Fix z.record() calls to use 2-arg form for Zod 4 compatibility.
 * Zod 4 requires z.record(keySchema, valueSchema) — the library generates
 * Zod 3 style z.record(valueSchema) with a single argument.
 *
 * Uses a parenthesis-aware parser to correctly handle nested expressions.
 */
function fixRecordArgs(zodExpr: string): string {
  const marker = 'z.record(';
  let result = '';
  let i = 0;

  while (i < zodExpr.length) {
    const idx = zodExpr.indexOf(marker, i);
    if (idx === -1) {
      result += zodExpr.slice(i);
      break;
    }

    result += zodExpr.slice(i, idx + marker.length);
    i = idx + marker.length;

    // Extract the full arguments by counting parentheses
    let depth = 1;
    let argStart = i;
    while (i < zodExpr.length && depth > 0) {
      if (zodExpr[i] === '(') depth++;
      else if (zodExpr[i] === ')') depth--;
      if (depth > 0) i++;
    }

    const argsStr = zodExpr.slice(argStart, i);

    // Check if there's a top-level comma (not inside nested parens)
    let hasTopLevelComma = false;
    let parenDepth = 0;
    for (const ch of argsStr) {
      if (ch === '(') parenDepth++;
      else if (ch === ')') parenDepth--;
      else if (ch === ',' && parenDepth === 0) {
        hasTopLevelComma = true;
        break;
      }
    }

    if (hasTopLevelComma) {
      // Already has 2+ args, recursively fix any nested z.record() in the args
      result += fixRecordArgs(argsStr);
    } else {
      // Single arg — prepend z.string() key schema, recursively fix the value
      result += `z.string(), ${fixRecordArgs(argsStr)}`;
    }

    // Append the closing paren
    result += zodExpr[i];
    i++;
  }

  return result;
}

/**
 * Topological sort of $defs based on $ref dependencies.
 * Types that are referenced come before types that reference them.
 */
function topologicalSort(defs: Record<string, JsonSchemaDef>): string[] {
  const names = Object.keys(defs);
  const visited = new Set<string>();
  const result: string[] = [];

  function getDeps(def: JsonSchemaDef): string[] {
    const deps: string[] = [];
    const walk = (obj: unknown) => {
      if (!obj || typeof obj !== 'object') return;
      const record = obj as Record<string, unknown>;
      if (record.$ref && typeof record.$ref === 'string') {
        const name = resolveRefName(record.$ref as string);
        if (name && names.includes(name)) {
          deps.push(name);
        }
      }
      for (const val of Object.values(record)) {
        if (Array.isArray(val)) {
          val.forEach(walk);
        } else if (typeof val === 'object' && val !== null) {
          walk(val);
        }
      }
    };
    walk(def);
    return deps;
  }

  function visit(name: string) {
    if (visited.has(name)) return;
    visited.add(name);
    for (const dep of getDeps(defs[name])) {
      visit(dep);
    }
    result.push(name);
  }

  for (const name of names) {
    visit(name);
  }

  return result;
}
