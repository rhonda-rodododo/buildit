/**
 * Migration Diff Generator
 *
 * When multiple v*.json files exist for a module, generates migration
 * stubs that transform data between schema versions.
 *
 * Also generates a version.ts file with DB_SCHEMA_VERSION and MODULE_VERSIONS.
 */

import { readFile } from 'fs/promises';
import { glob } from 'glob';
import { basename, dirname, join } from 'path';
import type { ModuleSchema, JsonSchemaDef } from '../utils/json-schema';
import { pascalCase, constCase } from '../utils/json-schema';

interface FieldDiff {
  added: string[];
  removed: string[];
  typeChanged: Array<{ field: string; from: string; to: string }>;
  possibleRenames: Array<{ from: string; to: string; confidence: number }>;
}

interface MigrationInfo {
  moduleName: string;
  fromVersion: string;
  toVersion: string;
  diffs: Record<string, FieldDiff>; // keyed by type name
}

/**
 * Generate the DB version file with schema version tracking.
 */
export function generateVersionFile(
  moduleVersions: Record<string, string>,
  totalTableCount: number
): string {
  let code = `/**
 * @generated by tools/codegen
 *
 * DO NOT EDIT - Database schema version constants
 */

/**
 * Global DB schema version. Increment when any module schema changes.
 * Based on total table count across all modules to ensure Dexie
 * upgrades trigger when new tables are added.
 */
export const DB_SCHEMA_VERSION = ${totalTableCount + 1};

/**
 * Per-module schema versions from protocol schemas.
 */
export const MODULE_VERSIONS: Record<string, string> = {\n`;

  for (const [module, version] of Object.entries(moduleVersions).sort()) {
    code += `  '${module}': '${version}',\n`;
  }

  code += `};\n`;
  return code;
}

/**
 * Scan for modules with multiple versions and generate migration stubs.
 */
export async function generateMigrations(
  schemasDir: string
): Promise<{ code: string; migrations: MigrationInfo[] }> {
  const allSchemaFiles = await glob(`${schemasDir}/**/v*.json`);
  const moduleFiles: Record<string, string[]> = {};

  for (const file of allSchemaFiles) {
    const moduleName = basename(dirname(file));
    if (!moduleFiles[moduleName]) moduleFiles[moduleName] = [];
    moduleFiles[moduleName].push(file);
  }

  const migrations: MigrationInfo[] = [];

  for (const [moduleName, files] of Object.entries(moduleFiles)) {
    if (files.length < 2) continue;

    // Sort by version number
    const sorted = files.sort((a, b) => {
      const vA = parseInt(basename(a).replace('v', '').replace('.json', ''));
      const vB = parseInt(basename(b).replace('v', '').replace('.json', ''));
      return vA - vB;
    });

    // Diff consecutive versions
    for (let i = 0; i < sorted.length - 1; i++) {
      const fromContent = await readFile(sorted[i], 'utf-8');
      const toContent = await readFile(sorted[i + 1], 'utf-8');
      const fromSchema: ModuleSchema = JSON.parse(fromContent);
      const toSchema: ModuleSchema = JSON.parse(toContent);

      const migration = diffSchemas(moduleName, fromSchema, toSchema);
      if (migration) {
        migrations.push(migration);
      }
    }
  }

  const code = renderMigrationIndex(migrations);
  return { code, migrations };
}

function diffSchemas(
  moduleName: string,
  from: ModuleSchema,
  to: ModuleSchema
): MigrationInfo | null {
  const fromDefs = from.$defs || {};
  const toDefs = to.$defs || {};
  const diffs: Record<string, FieldDiff> = {};
  let hasChanges = false;

  // Check each type in the new schema
  for (const [typeName, toDef] of Object.entries(toDefs)) {
    const fromDef = fromDefs[typeName];
    if (!fromDef) {
      // Entirely new type
      diffs[typeName] = {
        added: Object.keys(toDef.properties || {}),
        removed: [],
        typeChanged: [],
        possibleRenames: [],
      };
      hasChanges = true;
      continue;
    }

    const diff = diffFields(fromDef, toDef);
    if (diff.added.length > 0 || diff.removed.length > 0 ||
        diff.typeChanged.length > 0 || diff.possibleRenames.length > 0) {
      diffs[typeName] = diff;
      hasChanges = true;
    }
  }

  // Check for removed types
  for (const typeName of Object.keys(fromDefs)) {
    if (!toDefs[typeName]) {
      diffs[typeName] = {
        added: [],
        removed: Object.keys(fromDefs[typeName].properties || {}),
        typeChanged: [],
        possibleRenames: [],
      };
      hasChanges = true;
    }
  }

  if (!hasChanges) return null;

  return {
    moduleName,
    fromVersion: from.version,
    toVersion: to.version,
    diffs,
  };
}

function diffFields(from: JsonSchemaDef, to: JsonSchemaDef): FieldDiff {
  const fromProps = new Set(Object.keys(from.properties || {}));
  const toProps = new Set(Object.keys(to.properties || {}));

  const added = [...toProps].filter((p) => !fromProps.has(p));
  const removed = [...fromProps].filter((p) => !toProps.has(p));

  // Detect type changes in fields that exist in both
  const typeChanged: FieldDiff['typeChanged'] = [];
  for (const prop of [...fromProps].filter((p) => toProps.has(p))) {
    const fromType = JSON.stringify(from.properties![prop].type);
    const toType = JSON.stringify(to.properties![prop].type);
    if (fromType !== toType) {
      typeChanged.push({ field: prop, from: fromType, to: toType });
    }
  }

  // Heuristic rename detection: look for pairs where a removed field
  // and an added field have similar types
  const possibleRenames: FieldDiff['possibleRenames'] = [];
  for (const rem of removed) {
    for (const add of added) {
      const remType = JSON.stringify(from.properties![rem]);
      const addType = JSON.stringify(to.properties![add]);
      // Simple similarity check
      if (remType === addType) {
        possibleRenames.push({ from: rem, to: add, confidence: 0.9 });
      } else if (
        from.properties![rem].type === to.properties![add].type
      ) {
        possibleRenames.push({ from: rem, to: add, confidence: 0.5 });
      }
    }
  }

  return { added, removed, typeChanged, possibleRenames };
}

function renderMigrationIndex(migrations: MigrationInfo[]): string {
  if (migrations.length === 0) {
    return `/**
 * @generated by tools/codegen
 *
 * DO NOT EDIT - Migration stubs
 *
 * No schema version migrations detected (all modules at v1).
 */

export const MIGRATIONS: Record<string, Array<{ from: string; to: string; migrate: (data: Record<string, unknown>) => Record<string, unknown> }>> = {};
`;
  }

  let code = `/**
 * @generated by tools/codegen
 *
 * DO NOT EDIT - Migration stubs for schema version changes
 *
 * Review and complete TODO items before deploying.
 */

export interface MigrationStep {
  from: string;
  to: string;
  migrate: (data: Record<string, unknown>) => Record<string, unknown>;
}

export const MIGRATIONS: Record<string, MigrationStep[]> = {\n`;

  for (const migration of migrations) {
    const pascal = pascalCase(migration.moduleName);
    code += `  // ${pascal}: v${migration.fromVersion} → v${migration.toVersion}\n`;
    code += `  '${migration.moduleName}': [\n`;
    code += `    {\n`;
    code += `      from: '${migration.fromVersion}',\n`;
    code += `      to: '${migration.toVersion}',\n`;
    code += `      migrate: (data) => {\n`;

    for (const [typeName, diff] of Object.entries(migration.diffs)) {
      code += `        // ${typeName}:\n`;

      for (const rename of diff.possibleRenames) {
        code += `        // TODO: Verify rename: ${rename.from} → ${rename.to} (confidence: ${rename.confidence})\n`;
        code += `        if ('${rename.from}' in data) {\n`;
        code += `          data['${rename.to}'] = data['${rename.from}'];\n`;
        code += `          delete data['${rename.from}'];\n`;
        code += `        }\n`;
      }

      for (const added of diff.added) {
        if (!diff.possibleRenames.some((r) => r.to === added)) {
          code += `        // TODO: Set default for new field '${added}'\n`;
          code += `        // data['${added}'] = undefined;\n`;
        }
      }

      for (const change of diff.typeChanged) {
        code += `        // TODO: Type changed for '${change.field}': ${change.from} → ${change.to}\n`;
      }
    }

    code += `        return data;\n`;
    code += `      },\n`;
    code += `    },\n`;
    code += `  ],\n`;
  }

  code += `};\n`;
  return code;
}
