#!/usr/bin/env bun
/**
 * Schema Code Generator
 *
 * Generates native type definitions, DB schemas, Zod validation, and
 * migration stubs from JSON Schema files.
 *
 * Generators:
 *   - quicktype: TypeScript, Swift, Kotlin, Rust type interfaces
 *   - dexie: Dexie DB interfaces + TableSchema from x-storage
 *   - zod: Zod validation schemas from $defs
 *   - migration: Version migration stubs when v2+ detected
 *
 * Usage:
 *   bun run src/index.ts                    # Generate all targets
 *   bun run src/index.ts --target=typescript
 *   bun run src/index.ts --validate         # Validate only
 *   bun run src/index.ts --validate-vectors # Validate test vectors
 */

import { glob } from 'glob';
import { readFile, writeFile, mkdir } from 'fs/promises';
import { dirname, basename, join } from 'path';

import type { ModuleSchema, XStorageAnnotation } from './utils/json-schema';
import { pascalCase, constCase, snakeCase } from './utils/json-schema';
import { postProcessTypeScript, postProcessSwift, postProcessRust } from './utils/post-process';
import { generateAllTypesWithQuicktype } from './generators/quicktype';
import { generateDexieSchema } from './generators/dexie';
import { generateZodSchemas } from './generators/zod';
import { generateVersionFile, generateMigrations } from './generators/migration';

const REPO_ROOT = join(import.meta.dir, '../../..');
const SCHEMAS_DIR = join(REPO_ROOT, 'protocol/schemas/modules');
const TEST_VECTORS_DIR = join(REPO_ROOT, 'protocol/test-vectors');

// ============================================================================
// Target Configuration
// ============================================================================

interface Target {
  name: string;
  lang: string;
  outputDir: string;
  ext: string;
}

const TARGETS: Target[] = [
  {
    name: 'typescript',
    lang: 'typescript',
    outputDir: join(REPO_ROOT, 'clients/web/src/generated/schemas'),
    ext: '.ts',
  },
  {
    name: 'swift',
    lang: 'swift',
    outputDir: join(REPO_ROOT, 'clients/ios/Sources/Generated/Schemas'),
    ext: '.swift',
  },
  {
    name: 'kotlin',
    lang: 'kotlin',
    outputDir: join(REPO_ROOT, 'clients/android/app/src/main/java/network/buildit/generated/schemas'),
    ext: '.kt',
  },
  {
    name: 'rust',
    lang: 'rust',
    outputDir: join(REPO_ROOT, 'packages/crypto/src/generated/schemas'),
    ext: '.rs',
  },
];

// New generated output dirs for web client
const DEXIE_OUTPUT_DIR = join(REPO_ROOT, 'clients/web/src/generated/db');
const ZOD_OUTPUT_DIR = join(REPO_ROOT, 'clients/web/src/generated/validation');
const MIGRATION_OUTPUT_DIR = join(REPO_ROOT, 'clients/web/src/generated/migrations');

// ============================================================================
// Formatting
// ============================================================================

function formatOutput(
  moduleName: string,
  version: string,
  minReaderVersion: string,
  generatedCode: string,
  lang: string
): string {
  const moduleConst = constCase(moduleName);
  const pascalModule = pascalCase(moduleName);

  const header = `/**
 * @generated from protocol/schemas/modules/${moduleName}/v${version.split('.')[0]}.json
 * @version ${version}
 * @minReaderVersion ${minReaderVersion}
 *
 * DO NOT EDIT - This file is auto-generated by tools/codegen using quicktype
 */

`;

  switch (lang) {
    case 'typescript': {
      const processedTS = postProcessTypeScript(generatedCode);
      return (
        header +
        `// Version constants
export const ${moduleConst}_VERSION = '${version}';
export const ${moduleConst}_MIN_READER_VERSION = '${minReaderVersion}';

` +
        processedTS
      );
    }

    case 'swift': {
      const processedSwift = postProcessSwift(generatedCode);
      return (
        header +
        `import Foundation

public enum ${pascalModule}Schema {
    public static let version = "${version}"
    public static let minReaderVersion = "${minReaderVersion}"
}

` +
        processedSwift
      );
    }

    case 'kotlin':
      return header + generatedCode;

    case 'rust': {
      const processedRust = postProcessRust(generatedCode);
      const snakeModule = snakeCase(moduleName);
      return `//! ${pascalModule} module schema types
//!
//! @generated from protocol/schemas/modules/${moduleName}/v${version.split('.')[0]}.json
//! Version: ${version}
//! Min Reader Version: ${minReaderVersion}
//!
//! DO NOT EDIT - This file is auto-generated by tools/codegen using quicktype

use serde::{Deserialize, Serialize};

/// Schema version for ${pascalModule} module
pub const ${snakeModule.toUpperCase()}_VERSION: &str = "${version}";
/// Minimum reader version for ${pascalModule} module
pub const ${snakeModule.toUpperCase()}_MIN_READER_VERSION: &str = "${minReaderVersion}";

${processedRust}
`;
    }

    default:
      return header + generatedCode;
  }
}

// ============================================================================
// Index File Generation
// ============================================================================

interface ExportInfo {
  name: string;
  kind: 'type' | 'value';
}

async function generateTypeScriptIndex(schemaFiles: string[]) {
  const outputDir = join(REPO_ROOT, 'clients/web/src/generated/schemas');
  const modules = schemaFiles.map((f) => basename(dirname(f)));

  const moduleExports: Map<string, ExportInfo[]> = new Map();

  for (const moduleName of modules) {
    const generatedFile = join(outputDir, `${moduleName}.ts`);
    try {
      const content = await readFile(generatedFile, 'utf-8');
      const exports: ExportInfo[] = [];

      const interfaceMatches = content.matchAll(/export\s+interface\s+(\w+)/g);
      for (const match of interfaceMatches) {
        exports.push({ name: match[1], kind: 'type' });
      }

      const enumMatches = content.matchAll(/export\s+enum\s+(\w+)/g);
      for (const match of enumMatches) {
        exports.push({ name: match[1], kind: 'value' });
      }

      const constMatches = content.matchAll(/export\s+const\s+(\w+)/g);
      for (const match of constMatches) {
        exports.push({ name: match[1], kind: 'value' });
      }

      moduleExports.set(moduleName, exports);
    } catch {
      moduleExports.set(moduleName, []);
    }
  }

  const allExports: Map<string, string[]> = new Map();
  for (const [moduleName, exports] of moduleExports) {
    for (const exp of exports) {
      if (!allExports.has(exp.name)) allExports.set(exp.name, []);
      allExports.get(exp.name)!.push(moduleName);
    }
  }

  const conflicts = new Set<string>();
  for (const [exp, mods] of allExports) {
    if (mods.length > 1) conflicts.add(exp);
  }

  let code = '// Auto-generated index - DO NOT EDIT\n';
  code += '// For conflicting types, import directly from the module file\n\n';

  for (const moduleName of modules) {
    const pascalModule = pascalCase(moduleName);
    const moduleConst = constCase(moduleName);
    const exports = moduleExports.get(moduleName) || [];

    code += `// ${pascalModule} module\n`;
    code += `export { ${moduleConst}_VERSION, ${moduleConst}_MIN_READER_VERSION } from './${moduleName}';\n`;

    const typeExports: string[] = [];
    const valueExports: string[] = [];

    for (const exp of exports) {
      if (exp.name === `${moduleConst}_VERSION` || exp.name === `${moduleConst}_MIN_READER_VERSION`) {
        continue;
      }

      const exportName = conflicts.has(exp.name)
        ? `${exp.name} as ${pascalModule}${exp.name}`
        : exp.name;

      if (exp.kind === 'type') {
        typeExports.push(exportName);
      } else {
        valueExports.push(exportName);
      }
    }

    if (typeExports.length > 0) {
      code += `export type { ${typeExports.join(', ')} } from './${moduleName}';\n`;
    }

    if (valueExports.length > 0) {
      code += `export { ${valueExports.join(', ')} } from './${moduleName}';\n`;
    }

    code += '\n';
  }

  await writeFile(join(outputDir, 'index.ts'), code);
  console.log(`  ‚úÖ TypeScript: index.ts`);
}

async function generateRustMod(schemaFiles: string[]) {
  const outputDir = join(REPO_ROOT, 'packages/crypto/src/generated/schemas');
  const modules = schemaFiles.map((f) => basename(dirname(f)));

  let code = `//! Auto-generated schema module index
//!
//! DO NOT EDIT - This file is auto-generated by tools/codegen
//!
//! Each schema module is exposed separately to avoid type name conflicts.
//! Import directly from the module you need:
//!
//! \`\`\`rust
//! use buildit_crypto::generated::schemas::messaging::DirectMessage;
//! use buildit_crypto::generated::schemas::events::Event;
//! \`\`\`

`;

  for (const moduleName of modules) {
    const snakeModule = snakeCase(moduleName);
    code += `pub mod ${snakeModule};\n`;
  }

  await writeFile(join(outputDir, 'mod.rs'), code);
  console.log(`  ‚úÖ Rust: mod.rs`);
}

/**
 * Generate index files for Dexie DB schemas and Zod validation schemas.
 */
/**
 * Generate a conflict-safe index file by scanning generated files for exports
 * and aliasing any duplicates with a module prefix.
 */
async function generateConflictSafeIndex(
  outputDir: string,
  modules: string[],
  suffix: string,
  headerComment: string
): Promise<void> {
  // Scan all generated files for their exports
  const moduleExports: Map<string, { types: string[]; values: string[] }> = new Map();

  for (const moduleName of modules) {
    const filePath = join(outputDir, `${moduleName}.${suffix}.ts`);
    try {
      const content = await readFile(filePath, 'utf-8');
      const types: string[] = [];
      const values: string[] = [];

      for (const match of content.matchAll(/export\s+interface\s+(\w+)/g)) {
        types.push(match[1]);
      }
      for (const match of content.matchAll(/export\s+type\s+(\w+)/g)) {
        types.push(match[1]);
      }
      for (const match of content.matchAll(/export\s+const\s+(\w+)/g)) {
        values.push(match[1]);
      }

      moduleExports.set(moduleName, { types, values });
    } catch {
      moduleExports.set(moduleName, { types: [], values: [] });
    }
  }

  // Find conflicting names across modules
  const allNames: Map<string, string[]> = new Map();
  for (const [moduleName, exports] of moduleExports) {
    for (const name of [...exports.types, ...exports.values]) {
      if (!allNames.has(name)) allNames.set(name, []);
      allNames.get(name)!.push(moduleName);
    }
  }
  const conflicts = new Set(
    [...allNames.entries()].filter(([, mods]) => mods.length > 1).map(([name]) => name)
  );

  // Generate index with explicit named exports
  let code = `// Auto-generated index - DO NOT EDIT\n`;
  code += `// ${headerComment}\n`;
  if (conflicts.size > 0) {
    code += `// Conflicting names are prefixed with module name to avoid ambiguity\n`;
  }
  code += `\n`;

  for (const moduleName of modules) {
    const pascal = pascalCase(moduleName);
    const exports = moduleExports.get(moduleName);
    if (!exports) continue;

    code += `// ${pascal}\n`;

    const typeExports: string[] = [];
    const valueExports: string[] = [];

    for (const name of exports.types) {
      if (conflicts.has(name)) {
        typeExports.push(`${name} as ${pascal}${name}`);
      } else {
        typeExports.push(name);
      }
    }

    for (const name of exports.values) {
      if (conflicts.has(name)) {
        valueExports.push(`${name} as ${pascal}${name}`);
      } else {
        valueExports.push(name);
      }
    }

    if (typeExports.length > 0) {
      code += `export type { ${typeExports.join(', ')} } from './${moduleName}.${suffix}';\n`;
    }
    if (valueExports.length > 0) {
      code += `export { ${valueExports.join(', ')} } from './${moduleName}.${suffix}';\n`;
    }
    code += `\n`;
  }

  await writeFile(join(outputDir, 'index.ts'), code);
}

async function generateDexieIndex(modules: string[]) {
  await generateConflictSafeIndex(
    DEXIE_OUTPUT_DIR,
    modules,
    'db',
    'Dexie DB schema definitions generated from protocol x-storage annotations'
  );
  console.log(`  ‚úÖ Dexie: index.ts`);
}

async function generateZodIndex(modules: string[]) {
  await generateConflictSafeIndex(
    ZOD_OUTPUT_DIR,
    modules,
    'zod',
    'Zod validation schemas generated from protocol schema definitions'
  );
  console.log(`  ‚úÖ Zod: index.ts`);
}

// ============================================================================
// Validation
// ============================================================================

async function validateSchemas(schemaFiles: string[]): Promise<boolean> {
  console.log('Validating schemas...');
  let hasErrors = false;

  for (const file of schemaFiles) {
    const content = await readFile(file, 'utf-8');
    try {
      const schema: ModuleSchema = JSON.parse(content);

      if (!schema.version) {
        console.error(`  ‚ùå ${basename(dirname(file))}/${basename(file)}: Missing version field`);
        hasErrors = true;
        continue;
      }

      if (schema.$defs) {
        for (const [typeName, typeDef] of Object.entries(schema.$defs)) {
          if (typeDef.type === 'object' && typeDef.required) {
            if (!typeDef.properties?._v) {
              console.warn(`  ‚ö†Ô∏è  ${basename(dirname(file))}/${typeName}: Missing _v property (recommended for versioning)`);
            }
          }
        }
      }

      // Validate x-storage references
      const xStorage = schema['x-storage'];
      if (xStorage) {
        for (const [tableName, tableConfig] of Object.entries(xStorage.tables)) {
          if (!schema.$defs?.[tableConfig.type]) {
            console.error(`  ‚ùå ${basename(dirname(file))}: x-storage table '${tableName}' references unknown type '${tableConfig.type}'`);
            hasErrors = true;
          }
        }
      }

      console.log(`  ‚úÖ ${basename(dirname(file))}/${basename(file)} (v${schema.version})`);
    } catch (e) {
      console.error(`  ‚ùå ${file}: ${e}`);
      hasErrors = true;
    }
  }

  return !hasErrors;
}

async function validateTestVectors() {
  console.log('Validating schema versioning test vectors...\n');

  const vectorFiles = await glob(`${TEST_VECTORS_DIR}/*.json`);

  if (vectorFiles.length === 0) {
    console.log('  No test vector files found');
    return;
  }

  let totalTests = 0;
  let passedTests = 0;
  let failedTests = 0;
  let skippedFiles = 0;

  for (const file of vectorFiles) {
    const content = await readFile(file, 'utf-8');
    const vectors = JSON.parse(content);

    const isSchemaVersioningTest = vectors.testCases?.some((tc: Record<string, unknown>) => {
      const expected = tc.expected as Record<string, unknown> | undefined;
      return tc.module && (expected?.canParse !== undefined || expected?.unknownFields);
    });

    if (!isSchemaVersioningTest) {
      skippedFiles++;
      continue;
    }

    console.log(`üìÑ ${basename(file)}`);

    if (!vectors.testCases || !Array.isArray(vectors.testCases)) {
      console.log('  ‚ö†Ô∏è  No test cases found');
      continue;
    }

    for (const testCase of vectors.testCases) {
      totalTests++;

      try {
        if (!testCase.id || !testCase.name || !testCase.input || !testCase.expected) {
          throw new Error('Missing required test case fields');
        }

        const input = testCase.input;
        const expected = testCase.expected;

        if (expected.unknownFields && expected.unknownFields.length > 0) {
          for (const field of expected.unknownFields) {
            if (!(field in input)) {
              throw new Error(`Unknown field '${field}' not present in input`);
            }
          }
        }

        if (expected.relayOutput) {
          for (const field of (expected.unknownFields || [])) {
            if (!(field in expected.relayOutput)) {
              throw new Error(`Unknown field '${field}' not preserved in relay output`);
            }
          }
        }

        console.log(`  ‚úÖ ${testCase.id}: ${testCase.name}`);
        passedTests++;
      } catch (error) {
        console.error(`  ‚ùå ${testCase.id}: ${testCase.name}`);
        console.error(`     ${error instanceof Error ? error.message : String(error)}`);
        failedTests++;
      }
    }
    console.log('');
  }

  console.log(`\nResults: ${passedTests}/${totalTests} passed, ${failedTests} failed`);
  if (skippedFiles > 0) {
    console.log(`(Skipped ${skippedFiles} non-schema-versioning test files)`);
  }

  if (failedTests > 0) {
    process.exit(1);
  }
}

// ============================================================================
// Main
// ============================================================================

async function main() {
  const args = process.argv.slice(2);
  const validateOnly = args.includes('--validate');
  const validateVectorsFlag = args.includes('--validate-vectors');
  const targetFilter = args.find((a) => a.startsWith('--target='))?.split('=')[1];
  const skipQuicktype = args.includes('--skip-quicktype');

  console.log('üì¶ BuildIt Schema Code Generator\n');

  // Find all schema files
  const schemaFiles = await glob(`${SCHEMAS_DIR}/**/v*.json`);
  console.log(`Found ${schemaFiles.length} schema files\n`);

  if (validateVectorsFlag) {
    await validateTestVectors();
    return;
  }

  if (validateOnly) {
    const valid = await validateSchemas(schemaFiles);
    if (!valid) {
      console.log('\n‚ùå Validation failed');
      process.exit(1);
    }
    console.log('\n‚úÖ All schemas valid');
    return;
  }

  // Collect module info for version tracking
  const moduleVersions: Record<string, string> = {};
  let totalTableCount = 0;

  // ‚îÄ‚îÄ Phase 1: Quicktype generation (existing) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (!skipQuicktype) {
    const activeTargets = targetFilter
      ? TARGETS.filter((t) => t.name === targetFilter)
      : TARGETS;

    for (const file of schemaFiles) {
      const content = await readFile(file, 'utf-8');
      const schema: ModuleSchema = JSON.parse(content);
      const moduleName = basename(dirname(file));

      console.log(`\nüìÑ Processing ${moduleName}...`);

      moduleVersions[moduleName] = schema.version;

      if (!schema.$defs || Object.keys(schema.$defs).length === 0) {
        console.log(`  ‚è≠Ô∏è  No $defs found, skipping`);
        continue;
      }

      for (const target of activeTargets) {
        await mkdir(target.outputDir, { recursive: true });

        try {
          const generatedCode = await generateAllTypesWithQuicktype(moduleName, schema, target.lang);
          const code = formatOutput(
            moduleName,
            schema.version || '1.0.0',
            schema.minReaderVersion || schema.version || '1.0.0',
            generatedCode,
            target.lang
          );
          const outputName = target.lang === 'rust' ? snakeCase(moduleName) : moduleName;
          const outputFile = join(target.outputDir, `${outputName}${target.ext}`);
          await writeFile(outputFile, code);
          console.log(`  ‚úÖ ${target.name}: ${outputName}${target.ext}`);
        } catch (error) {
          console.error(`  ‚ùå ${target.name}: ${error}`);
        }
      }
    }

    // Generate quicktype index files
    if (!targetFilter || targetFilter === 'typescript') {
      await generateTypeScriptIndex(schemaFiles);
    }
    if (!targetFilter || targetFilter === 'rust') {
      await generateRustMod(schemaFiles);
    }
  }

  // ‚îÄ‚îÄ Phase 2: Dexie DB schema generation (new) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (!targetFilter || targetFilter === 'typescript') {
    console.log('\nüóÑÔ∏è  Generating Dexie DB schemas...');
    await mkdir(DEXIE_OUTPUT_DIR, { recursive: true });

    const dexieModules: string[] = [];

    for (const file of schemaFiles) {
      const content = await readFile(file, 'utf-8');
      const schema: ModuleSchema = JSON.parse(content);
      const moduleName = basename(dirname(file));

      moduleVersions[moduleName] = schema.version;

      const xStorage = schema['x-storage'];
      if (xStorage) {
        totalTableCount += Object.keys(xStorage.tables).length;
      }

      const dexieCode = generateDexieSchema(moduleName, schema);
      if (dexieCode) {
        const outputFile = join(DEXIE_OUTPUT_DIR, `${moduleName}.db.ts`);
        await writeFile(outputFile, dexieCode);
        dexieModules.push(moduleName);
        console.log(`  ‚úÖ Dexie: ${moduleName}.db.ts`);
      }
    }

    await generateDexieIndex(dexieModules);
  }

  // ‚îÄ‚îÄ Phase 3: Zod validation schema generation (new) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (!targetFilter || targetFilter === 'typescript') {
    console.log('\n‚úÖ Generating Zod validation schemas...');
    await mkdir(ZOD_OUTPUT_DIR, { recursive: true });

    const zodModules: string[] = [];

    for (const file of schemaFiles) {
      const content = await readFile(file, 'utf-8');
      const schema: ModuleSchema = JSON.parse(content);
      const moduleName = basename(dirname(file));

      const zodCode = generateZodSchemas(moduleName, schema);
      if (zodCode) {
        const outputFile = join(ZOD_OUTPUT_DIR, `${moduleName}.zod.ts`);
        await writeFile(outputFile, zodCode);
        zodModules.push(moduleName);
        console.log(`  ‚úÖ Zod: ${moduleName}.zod.ts`);
      }
    }

    await generateZodIndex(zodModules);
  }

  // ‚îÄ‚îÄ Phase 4: Migration generation (new) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (!targetFilter || targetFilter === 'typescript') {
    console.log('\nüîÑ Generating migrations...');
    await mkdir(MIGRATION_OUTPUT_DIR, { recursive: true });

    const { code: migrationCode, migrations } = await generateMigrations(SCHEMAS_DIR);
    await writeFile(join(MIGRATION_OUTPUT_DIR, 'index.ts'), migrationCode);

    if (migrations.length > 0) {
      console.log(`  ‚úÖ Generated ${migrations.length} migration(s)`);
    } else {
      console.log(`  ‚ÑπÔ∏è  No version migrations needed (all modules at v1)`);
    }

    // Generate version file
    const versionCode = generateVersionFile(moduleVersions, totalTableCount);
    await writeFile(join(DEXIE_OUTPUT_DIR, 'version.ts'), versionCode);
    console.log(`  ‚úÖ Version: version.ts (DB_SCHEMA_VERSION=${totalTableCount + 1})`);
  }

  console.log('\n‚úÖ Code generation complete!');
}

main().catch(console.error);
