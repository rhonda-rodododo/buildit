#!/usr/bin/env bun
/**
 * Schema Code Generator
 *
 * Generates native type definitions from JSON Schema files.
 *
 * Usage:
 *   bun run src/index.ts                    # Generate all targets
 *   bun run src/index.ts --target typescript
 *   bun run src/index.ts --validate         # Validate only
 */

import { glob } from 'glob';
import { readFile, writeFile, mkdir } from 'fs/promises';
import { dirname, basename, join } from 'path';

const REPO_ROOT = join(import.meta.dir, '../../..');
const SCHEMAS_DIR = join(REPO_ROOT, 'protocol/schemas/modules');

interface Target {
  name: string;
  outputDir: string;
  generate: (schema: any, moduleName: string) => string;
  fileExtension: string;
}

const targets: Target[] = [
  {
    name: 'typescript',
    outputDir: join(REPO_ROOT, 'clients/web/src/generated/schemas'),
    fileExtension: '.ts',
    generate: generateTypeScript,
  },
  {
    name: 'swift',
    outputDir: join(REPO_ROOT, 'clients/ios/Sources/Generated/Schemas'),
    fileExtension: '.swift',
    generate: generateSwift,
  },
  {
    name: 'kotlin',
    outputDir: join(REPO_ROOT, 'clients/android/app/src/main/java/network/buildit/generated/schemas'),
    fileExtension: '.kt',
    generate: generateKotlin,
  },
];

async function main() {
  const args = process.argv.slice(2);
  const validateOnly = args.includes('--validate');
  const targetFilter = args.find(a => a.startsWith('--target='))?.split('=')[1];

  console.log('ðŸ“¦ BuildIt Schema Code Generator\n');

  // Find all schema files
  const schemaFiles = await glob(`${SCHEMAS_DIR}/**/v*.json`);
  console.log(`Found ${schemaFiles.length} schema files\n`);

  if (validateOnly) {
    console.log('Validating schemas...');
    for (const file of schemaFiles) {
      const content = await readFile(file, 'utf-8');
      try {
        JSON.parse(content);
        console.log(`  âœ… ${basename(dirname(file))}/${basename(file)}`);
      } catch (e) {
        console.error(`  âŒ ${file}: ${e}`);
        process.exit(1);
      }
    }
    console.log('\nâœ… All schemas valid');
    return;
  }

  // Generate for each target
  const activeTargets = targetFilter
    ? targets.filter(t => t.name === targetFilter)
    : targets;

  for (const target of activeTargets) {
    console.log(`\nðŸŽ¯ Generating ${target.name}...`);
    await mkdir(target.outputDir, { recursive: true });

    for (const file of schemaFiles) {
      const content = await readFile(file, 'utf-8');
      const schema = JSON.parse(content);
      const moduleName = basename(dirname(file));

      const code = target.generate(schema, moduleName);
      const outputFile = join(target.outputDir, `${moduleName}${target.fileExtension}`);

      await writeFile(outputFile, code);
      console.log(`  âœ… ${moduleName}${target.fileExtension}`);
    }

    // Generate index file for TypeScript
    if (target.name === 'typescript') {
      const modules = schemaFiles.map(f => basename(dirname(f)));
      const indexContent = modules
        .map(m => `export * from './${m}';`)
        .join('\n') + '\n';
      await writeFile(join(target.outputDir, 'index.ts'), indexContent);
      console.log('  âœ… index.ts');
    }
  }

  console.log('\nâœ… Code generation complete!');
}

function generateTypeScript(schema: any, moduleName: string): string {
  const version = schema.version || '1.0.0';
  const minReaderVersion = schema.minReaderVersion || version;

  let code = `/**
 * @generated from protocol/schemas/modules/${moduleName}/v${version.split('.')[0]}.json
 * @version ${version}
 * @minReaderVersion ${minReaderVersion}
 *
 * DO NOT EDIT - This file is auto-generated by tools/codegen
 */

import { z } from 'zod';

// Version constants
export const ${moduleName.toUpperCase().replace(/-/g, '_')}_VERSION = '${version}';
export const ${moduleName.toUpperCase().replace(/-/g, '_')}_MIN_READER_VERSION = '${minReaderVersion}';

`;

  // Generate Zod schemas for each definition
  if (schema.$defs) {
    for (const [name, def] of Object.entries(schema.$defs)) {
      code += generateZodSchema(name, def as any);
      code += `\nexport type ${name} = z.infer<typeof ${name}Schema>;\n\n`;
    }
  }

  return code;
}

function generateZodSchema(name: string, def: any): string {
  // Simplified Zod generation - real implementation would be more complete
  let schema = `export const ${name}Schema = z.object({\n`;

  if (def.properties) {
    for (const [propName, propDef] of Object.entries(def.properties)) {
      const prop = propDef as any;
      const isRequired = def.required?.includes(propName);

      let zodType = 'z.unknown()';
      if (prop.type === 'string') {
        zodType = 'z.string()';
        if (prop.format === 'uuid') zodType += '.uuid()';
        if (prop.maxLength) zodType += `.max(${prop.maxLength})`;
        if (prop.pattern) zodType += `.regex(/${prop.pattern}/)`;
      } else if (prop.type === 'integer' || prop.type === 'number') {
        zodType = 'z.number()';
        if (prop.type === 'integer') zodType += '.int()';
        if (prop.minimum !== undefined) zodType += `.min(${prop.minimum})`;
      } else if (prop.type === 'boolean') {
        zodType = 'z.boolean()';
      } else if (prop.type === 'array') {
        zodType = 'z.array(z.unknown())';
      } else if (prop.type === 'object') {
        zodType = 'z.record(z.unknown())';
      }

      if (!isRequired) zodType += '.optional()';
      if (prop.default !== undefined) zodType += `.default(${JSON.stringify(prop.default)})`;

      schema += `  ${propName}: ${zodType},\n`;
    }
  }

  schema += `}).passthrough(); // Preserve unknown fields for relay\n`;
  return schema;
}

function generateSwift(schema: any, moduleName: string): string {
  const version = schema.version || '1.0.0';
  const pascalName = moduleName
    .split('-')
    .map(s => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');

  let code = `/**
 * @generated from protocol/schemas/modules/${moduleName}/v${version.split('.')[0]}.json
 * @version ${version}
 *
 * DO NOT EDIT - This file is auto-generated by tools/codegen
 */

import Foundation

public enum ${pascalName}Schema {
    public static let version = "${version}"
    public static let minReaderVersion = "${schema.minReaderVersion || version}"
}

`;

  if (schema.$defs) {
    for (const [name, def] of Object.entries(schema.$defs)) {
      code += generateSwiftStruct(name, def as any);
    }
  }

  return code;
}

function generateSwiftStruct(name: string, def: any): string {
  let code = `public struct ${name}: Codable, Sendable {\n`;

  if (def.properties) {
    for (const [propName, propDef] of Object.entries(def.properties)) {
      const prop = propDef as any;
      const isRequired = def.required?.includes(propName);

      let swiftType = 'Any';
      if (prop.type === 'string') {
        swiftType = prop.format === 'uuid' ? 'UUID' : 'String';
      } else if (prop.type === 'integer') {
        swiftType = 'Int64';
      } else if (prop.type === 'number') {
        swiftType = 'Double';
      } else if (prop.type === 'boolean') {
        swiftType = 'Bool';
      } else if (prop.type === 'array') {
        swiftType = '[AnyCodable]';
      } else if (prop.type === 'object') {
        swiftType = '[String: AnyCodable]';
      }

      const optionalMark = isRequired ? '' : '?';
      const camelName = propName.replace(/^_/, '');

      if (prop.description) {
        code += `    /// ${prop.description}\n`;
      }
      code += `    public let ${camelName}: ${swiftType}${optionalMark}\n`;
    }
  }

  code += `\n    /// Unknown fields preserved for relay forwarding\n`;
  code += `    private var _unknownFields: [String: AnyCodable] = [:]\n`;
  code += `}\n\n`;

  return code;
}

function generateKotlin(schema: any, moduleName: string): string {
  const version = schema.version || '1.0.0';
  const pascalName = moduleName
    .split('-')
    .map(s => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');

  let code = `/**
 * @generated from protocol/schemas/modules/${moduleName}/v${version.split('.')[0]}.json
 * @version ${version}
 *
 * DO NOT EDIT - This file is auto-generated by tools/codegen
 */

package network.buildit.generated.schemas

import kotlinx.serialization.*
import kotlinx.serialization.json.*

object ${pascalName}Schema {
    const val VERSION = "${version}"
    const val MIN_READER_VERSION = "${schema.minReaderVersion || version}"
}

`;

  if (schema.$defs) {
    for (const [name, def] of Object.entries(schema.$defs)) {
      code += generateKotlinDataClass(name, def as any);
    }
  }

  return code;
}

function generateKotlinDataClass(name: string, def: any): string {
  let code = `@Serializable\ndata class ${name}(\n`;

  const props: string[] = [];

  if (def.properties) {
    for (const [propName, propDef] of Object.entries(def.properties)) {
      const prop = propDef as any;
      const isRequired = def.required?.includes(propName);

      let kotlinType = 'JsonElement';
      if (prop.type === 'string') {
        kotlinType = 'String';
      } else if (prop.type === 'integer') {
        kotlinType = 'Long';
      } else if (prop.type === 'number') {
        kotlinType = 'Double';
      } else if (prop.type === 'boolean') {
        kotlinType = 'Boolean';
      } else if (prop.type === 'array') {
        kotlinType = 'List<JsonElement>';
      } else if (prop.type === 'object') {
        kotlinType = 'Map<String, JsonElement>';
      }

      const nullMark = isRequired ? '' : '?';
      const defaultVal = isRequired ? '' : ' = null';
      const serialName = propName.startsWith('_') ? `@SerialName("${propName}") ` : '';

      if (prop.description) {
        props.push(`    /** ${prop.description} */`);
      }
      props.push(`    ${serialName}val ${propName.replace(/^_/, '')}: ${kotlinType}${nullMark}${defaultVal},`);
    }
  }

  // Add unknown fields
  props.push(`    @Transient internal val unknownFields: Map<String, JsonElement> = emptyMap()`);

  code += props.join('\n');
  code += `\n)\n\n`;

  return code;
}

main().catch(console.error);
