//! Events module schema types
//!
//! @generated from protocol/schemas/modules/events/v1.json
//! Version: 1.0.0
//! Min Reader Version: 1.0.0
//!
//! DO NOT EDIT - This file is auto-generated by tools/codegen using quicktype

use serde::{Deserialize, Serialize};

/// Schema version for Events module
pub const EVENTS_VERSION: &str = "1.0.0";
/// Minimum reader version for Events module
pub const EVENTS_MIN_READER_VERSION: &str = "1.0.0";

use std::collections::HashMap;

/// An event with time, location, and RSVP tracking
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Event {
    /// Schema version that created this content
    #[serde(rename = "_v")]
    pub v: String,

    /// Whether this is an all-day event
    pub all_day: Option<bool>,

    pub attachments: Option<Vec<AttachmentElement>>,

    /// Creation timestamp (Unix seconds)
    pub created_at: i64,

    /// Creator's public key (hex)
    pub created_by: String,

    /// Custom field values (requires custom-fields module)
    pub custom_fields: Option<HashMap<String, Option<serde_json::Value>>>,

    /// Event description (markdown supported)
    pub description: Option<String>,

    /// End time as Unix timestamp (seconds)
    pub end_at: Option<i64>,

    /// Unique event identifier
    pub id: String,

    /// Signal-style encrypted link previews for URLs in event description
    pub link_previews: Option<Vec<LinkPreview>>,

    pub location: Option<LocationClass>,

    /// Maximum number of attendees
    pub max_attendees: Option<i64>,

    pub recurrence: Option<RecurrenceClass>,

    /// RSVP deadline as Unix timestamp
    pub rsvp_deadline: Option<i64>,

    /// Start time as Unix timestamp (seconds)
    pub start_at: i64,

    /// IANA timezone identifier (e.g., 'America/New_York')
    pub timezone: Option<String>,

    /// Event title
    pub title: String,

    /// Last update timestamp (Unix seconds)
    pub updated_at: Option<i64>,

    /// URL for virtual attendance
    pub virtual_url: Option<String>,

    /// Who can see this event
    pub visibility: Option<Visibility>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct AttachmentElement {
    pub mime_type: Option<String>,

    pub name: Option<String>,

    /// File size in bytes
    pub size: Option<i64>,

    #[serde(rename = "type")]
    pub attachment_type: Type,

    pub url: String,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Type {
    File,

    Image,

    Link,
}

/// Privacy-preserving link preview (Signal-style). Sender fetches OG metadata + thumbnail,
/// encrypts with content. Recipients see static previews — zero third-party requests.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LinkPreview {
    /// Open Graph og:description
    pub description: Option<String>,

    /// Base64-encoded favicon (max ~10KB)
    pub favicon_data: Option<String>,

    /// Favicon MIME type
    pub favicon_type: Option<String>,

    /// Unix timestamp when preview was generated
    pub fetched_at: i64,

    /// Who fetched the preview — sender (direct) or proxy (API worker)
    pub fetched_by: FetchedBy,

    /// Base64-encoded thumbnail (max ~50KB, encrypted with content)
    pub image_data: Option<String>,

    /// Image height in pixels
    pub image_height: Option<i64>,

    /// MIME type (image/jpeg, image/png, image/webp)
    pub image_type: Option<String>,

    /// Image width in pixels
    pub image_width: Option<i64>,

    /// Open Graph og:site_name
    pub site_name: Option<String>,

    /// Open Graph og:title
    pub title: Option<String>,

    /// Original URL
    pub url: String,
}

/// Who fetched the preview — sender (direct) or proxy (API worker)
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FetchedBy {
    Proxy,

    Sender,
}

/// Physical location for an event
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct LocationClass {
    /// Street address
    pub address: Option<String>,

    /// [latitude, longitude]
    pub coordinates: Option<Vec<f64>>,

    /// Access instructions
    pub instructions: Option<String>,

    /// Location name
    pub name: Option<String>,
}

/// iCal-style recurrence rule
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RecurrenceClass {
    pub by_day: Option<Vec<ByDay>>,

    /// Number of occurrences
    pub count: Option<i64>,

    pub frequency: Frequency,

    pub interval: Option<i64>,

    /// End date as Unix timestamp
    pub until: Option<i64>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ByDay {
    #[serde(rename = "FR")]
    Fr,

    #[serde(rename = "MO")]
    Mo,

    #[serde(rename = "SA")]
    Sa,

    #[serde(rename = "SU")]
    Su,

    #[serde(rename = "TH")]
    Th,

    #[serde(rename = "TU")]
    Tu,

    #[serde(rename = "WE")]
    We,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Frequency {
    Daily,

    Monthly,

    Weekly,

    Yearly,
}

/// Who can see this event
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Visibility {
    Group,

    Private,

    Public,
}

/// Physical location for an event
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Location {
    /// Street address
    pub address: Option<String>,

    /// [latitude, longitude]
    pub coordinates: Option<Vec<f64>>,

    /// Access instructions
    pub instructions: Option<String>,

    /// Location name
    pub name: Option<String>,
}

/// iCal-style recurrence rule
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RecurrenceRule {
    pub by_day: Option<Vec<ByDay>>,

    /// Number of occurrences
    pub count: Option<i64>,

    pub frequency: Frequency,

    pub interval: Option<i64>,

    /// End date as Unix timestamp
    pub until: Option<i64>,
}

/// RSVP response to an event
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Rsvp {
    #[serde(rename = "_v")]
    pub v: String,

    pub event_id: String,

    /// Additional guests
    pub guest_count: Option<i64>,

    pub note: Option<String>,

    pub pubkey: String,

    pub responded_at: i64,

    pub status: Status,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Status {
    Going,

    Maybe,

    #[serde(rename = "not_going")]
    NotGoing,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Attachment {
    pub mime_type: Option<String>,

    pub name: Option<String>,

    /// File size in bytes
    pub size: Option<i64>,

    #[serde(rename = "type")]
    pub attachment_type: Type,

    pub url: String,
}

