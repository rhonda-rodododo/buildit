//! Forms module schema types
//!
//! @generated from protocol/schemas/modules/forms/v1.json
//! Version: 1.0.0
//! Min Reader Version: 1.0.0
//!
//! DO NOT EDIT - This file is auto-generated by tools/codegen using quicktype

use serde::{Deserialize, Serialize};

/// Schema version for Forms module
pub const FORMS_VERSION: &str = "1.0.0";
/// Minimum reader version for Forms module
pub const FORMS_MIN_READER_VERSION: &str = "1.0.0";

use std::collections::HashMap;

/// A form with questions and settings
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Form {
    #[serde(rename = "_v")]
    pub v: String,

    /// Allow multiple submissions per user
    pub allow_multiple: Option<bool>,

    /// Whether responses are anonymous
    pub anonymous: Option<bool>,

    /// When form closes for submissions
    pub closes_at: Option<i64>,

    /// Message shown after submission
    pub confirmation_message: Option<String>,

    pub created_at: i64,

    pub created_by: String,

    pub description: Option<String>,

    pub fields: Vec<FieldElement>,

    pub group_id: Option<String>,

    pub id: String,

    /// Maximum number of responses
    pub max_responses: Option<i64>,

    /// When form opens for submissions
    pub opens_at: Option<i64>,

    pub status: Option<FormStatus>,

    pub title: String,

    pub updated_at: Option<i64>,

    pub visibility: Option<Visibility>,
}

/// A single form field/question
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FieldElement {
    pub conditional: Option<FieldConditional>,

    pub description: Option<String>,

    pub id: String,

    pub label: String,

    /// Options for select/radio/checkbox fields
    pub options: Option<Vec<FieldOption>>,

    pub placeholder: Option<String>,

    pub required: Option<bool>,

    #[serde(rename = "type")]
    pub form_field_type: Type,

    pub validation: Option<FieldValidationClass>,
}

/// Conditional display logic
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FieldConditional {
    pub field: String,

    pub operator: Operator,

    pub value: Option<serde_json::Value>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Operator {
    Contains,

    Equals,

    Greater,

    Less,

    #[serde(rename = "not_contains")]
    NotContains,

    #[serde(rename = "not_equals")]
    NotEquals,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Type {
    Checkbox,

    Date,

    Datetime,

    Email,

    File,

    Location,

    Multiselect,

    Number,

    Phone,

    Radio,

    Rating,

    Scale,

    Select,

    Text,

    Textarea,

    Time,

    Url,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FieldOption {
    pub label: String,

    pub value: String,
}

/// Validation rules for a field
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FieldValidationClass {
    pub custom_error: Option<String>,

    pub max: Option<f64>,

    pub max_length: Option<i64>,

    pub min: Option<f64>,

    pub min_length: Option<i64>,

    pub pattern: Option<String>,
}

/// Status of a form
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FormStatus {
    Archived,

    Closed,

    Draft,

    Open,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Visibility {
    Group,

    Private,

    Public,
}

/// A single form field/question
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FormField {
    pub conditional: Option<FormFieldConditional>,

    pub description: Option<String>,

    pub id: String,

    pub label: String,

    /// Options for select/radio/checkbox fields
    pub options: Option<Vec<FormFieldOption>>,

    pub placeholder: Option<String>,

    pub required: Option<bool>,

    #[serde(rename = "type")]
    pub form_field_type: Type,

    pub validation: Option<FormFieldValidation>,
}

/// Conditional display logic
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FormFieldConditional {
    pub field: String,

    pub operator: Operator,

    pub value: Option<serde_json::Value>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FormFieldOption {
    pub label: String,

    pub value: String,
}

/// Validation rules for a field
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FormFieldValidation {
    pub custom_error: Option<String>,

    pub max: Option<f64>,

    pub max_length: Option<i64>,

    pub min: Option<f64>,

    pub min_length: Option<i64>,

    pub pattern: Option<String>,
}

/// Validation rules for a field
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FieldValidation {
    pub custom_error: Option<String>,

    pub max: Option<f64>,

    pub max_length: Option<i64>,

    pub min: Option<f64>,

    pub min_length: Option<i64>,

    pub pattern: Option<String>,
}

/// Conditional display logic
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ConditionalLogic {
    pub field: String,

    pub operator: Operator,

    pub value: Option<serde_json::Value>,
}

/// A submitted form response
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FormResponse {
    #[serde(rename = "_v")]
    pub v: String,

    /// Field ID to answer value mapping
    pub answers: HashMap<String, Option<serde_json::Value>>,

    pub form_id: String,

    pub id: String,

    /// Respondent pubkey (null if anonymous)
    pub respondent: Option<String>,

    pub submitted_at: i64,
}

