//! Governance module schema types
//!
//! @generated from protocol/schemas/modules/governance/v1.json
//! Version: 1.0.0
//! Min Reader Version: 1.0.0
//!
//! DO NOT EDIT - This file is auto-generated by tools/codegen using quicktype

use serde::{Deserialize, Serialize};

/// Schema version for Governance module
pub const GOVERNANCE_VERSION: &str = "1.0.0";
/// Minimum reader version for Governance module
pub const GOVERNANCE_MIN_READER_VERSION: &str = "1.0.0";

use std::collections::HashMap;

/// A proposal for group decision-making
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Proposal {
    /// Schema version for graceful degradation
    #[serde(rename = "_v")]
    pub v: String,

    /// Allow abstention votes
    pub allow_abstain: Option<bool>,

    /// Allow vote delegation
    pub allow_delegation: Option<bool>,

    /// Whether votes are anonymous
    pub anonymous_voting: Option<bool>,

    /// Supporting documents
    pub attachments: Option<Vec<AttachmentElement>>,

    /// Unix timestamp of creation
    pub created_at: i64,

    /// Hex public key of creator
    pub created_by: String,

    /// Custom field values
    pub custom_fields: Option<HashMap<String, Option<serde_json::Value>>>,

    /// Detailed proposal description (markdown supported)
    pub description: Option<String>,

    /// Discussion period before voting
    pub discussion_period: Option<DiscussionPeriod>,

    /// Group this proposal belongs to
    pub group_id: String,

    /// Unique identifier for the proposal
    pub id: String,

    /// Available voting options
    pub options: Vec<OptionElement>,

    /// Configuration for quadratic voting (required when votingSystem is 'quadratic')
    pub quadratic_config: Option<QuadraticConfigClass>,

    pub quorum: Option<QuorumClass>,

    pub status: ProposalStatus,

    /// Categorization tags
    pub tags: Option<Vec<String>>,

    pub threshold: Option<ThresholdClass>,

    /// Proposal title
    pub title: String,

    #[serde(rename = "type")]
    pub proposal_type: ProposalType,

    /// Unix timestamp of last update
    pub updated_at: Option<i64>,

    /// Active voting period
    pub voting_period: VotingPeriod,

    pub voting_system: VotingSystem,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct AttachmentElement {
    pub mime_type: Option<String>,

    pub name: String,

    pub size: Option<i64>,

    #[serde(rename = "type")]
    pub proposal_attachment_type: AttachmentType,

    pub url: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum AttachmentType {
    Document,

    File,

    Url,
}

/// Discussion period before voting
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DiscussionPeriod {
    pub ends_at: i64,

    pub starts_at: i64,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct OptionElement {
    /// Display color
    pub color: Option<String>,

    /// Option description
    pub description: Option<String>,

    pub id: String,

    /// Display label
    pub label: String,

    /// Display order
    pub order: Option<i64>,
}

/// Type of proposal
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ProposalType {
    Action,

    Amendment,

    Budget,

    Election,

    General,

    Policy,

    Resolution,
}

/// Configuration for quadratic voting (required when votingSystem is 'quadratic')
///
/// Configuration for quadratic voting on a proposal
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct QuadraticConfigClass {
    /// Maximum tokens a voter can allocate to a single option (defaults to tokenBudget)
    pub max_tokens_per_option: Option<i64>,

    /// Total token budget each voter receives to allocate across options
    pub token_budget: i64,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct QuorumClass {
    /// Whether abstentions count toward quorum
    pub count_abstentions: Option<bool>,

    /// Type of quorum
    #[serde(rename = "type")]
    pub quorum_requirement_type: QuorumType,

    /// Quorum value (percentage 0-100 or absolute count)
    pub value: Option<f64>,
}

/// Type of quorum
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum QuorumType {
    Absolute,

    None,

    Percentage,
}

/// Current status of the proposal
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ProposalStatus {
    Discussion,

    Draft,

    Expired,

    Implemented,

    Passed,

    Rejected,

    Voting,

    Withdrawn,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ThresholdClass {
    /// Required percentage to pass
    pub percentage: Option<f64>,

    /// Type of threshold
    #[serde(rename = "type")]
    pub passing_threshold_type: ThresholdType,
}

/// Type of threshold
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub enum ThresholdType {
    Custom,

    #[serde(rename = "simple-majority")]
    SimpleMajority,

    Supermajority,

    Unanimous,
}

/// Active voting period
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct VotingPeriod {
    pub ends_at: i64,

    pub starts_at: i64,
}

/// Voting system to use
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub enum VotingSystem {
    Approval,

    Consensus,

    #[serde(rename = "d-hondt")]
    DHondt,

    #[serde(rename = "modified-consensus")]
    ModifiedConsensus,

    Quadratic,

    #[serde(rename = "ranked-choice")]
    RankedChoice,

    #[serde(rename = "simple-majority")]
    SimpleMajority,

    Supermajority,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct VoteOption {
    /// Display color
    pub color: Option<String>,

    /// Option description
    pub description: Option<String>,

    pub id: String,

    /// Display label
    pub label: String,

    /// Display order
    pub order: Option<i64>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct QuorumRequirement {
    /// Whether abstentions count toward quorum
    pub count_abstentions: Option<bool>,

    /// Type of quorum
    #[serde(rename = "type")]
    pub quorum_requirement_type: QuorumType,

    /// Quorum value (percentage 0-100 or absolute count)
    pub value: Option<f64>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PassingThreshold {
    /// Required percentage to pass
    pub percentage: Option<f64>,

    /// Type of threshold
    #[serde(rename = "type")]
    pub passing_threshold_type: ThresholdType,
}

/// A vote cast on a proposal
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Vote {
    #[serde(rename = "_v")]
    pub v: String,

    /// Unix timestamp when vote was cast
    pub cast_at: i64,

    /// Selected option(s) - single for simple, array for ranked-choice, QuadraticBallot for
    /// quadratic
    pub choice: Choice,

    /// Optional vote comment
    pub comment: Option<String>,

    /// Delegators whose votes this represents
    pub delegated_from: Option<Vec<String>>,

    pub id: String,

    pub proposal_id: String,

    /// Cryptographic signature of the vote
    pub signature: Option<String>,

    /// Voter's public key (may be encrypted for anonymous votes)
    pub voter_id: String,

    /// Vote weight (for weighted voting)
    pub weight: Option<f64>,
}

/// Selected option(s) - single for simple, array for ranked-choice, QuadraticBallot for
/// quadratic
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Choice {
    QuadraticBallotClass(QuadraticBallotClass),

    String(String),

    StringArray(Vec<String>),
}

/// A quadratic voting ballot with token allocations across options
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct QuadraticBallotClass {
    /// Map of option ID to number of tokens allocated. Effective votes = sqrt(tokens).
    pub allocations: HashMap<String, i64>,

    /// Total tokens used in this ballot (sum of all allocations, must not exceed budget)
    pub total_tokens: i64,
}

/// Vote delegation from one member to another
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Delegation {
    #[serde(rename = "_v")]
    pub v: String,

    /// Categories for category-scoped delegation
    pub category_tags: Option<Vec<String>>,

    pub created_at: i64,

    /// Person receiving the delegation
    pub delegate_id: String,

    /// Person delegating their vote
    pub delegator_id: String,

    pub id: String,

    /// Specific proposal for proposal-scoped delegation
    pub proposal_id: Option<String>,

    pub revoked: Option<bool>,

    /// Scope of the delegation
    pub scope: Scope,

    pub valid_from: Option<i64>,

    pub valid_until: Option<i64>,
}

/// Scope of the delegation
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Scope {
    All,

    Category,

    Proposal,
}

/// Configuration for quadratic voting on a proposal
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct QuadraticVotingConfig {
    /// Maximum tokens a voter can allocate to a single option (defaults to tokenBudget)
    pub max_tokens_per_option: Option<i64>,

    /// Total token budget each voter receives to allocate across options
    pub token_budget: i64,
}

/// A quadratic voting ballot with token allocations across options
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct QuadraticBallot {
    /// Map of option ID to number of tokens allocated. Effective votes = sqrt(tokens).
    pub allocations: HashMap<String, i64>,

    /// Total tokens used in this ballot (sum of all allocations, must not exceed budget)
    pub total_tokens: i64,
}

/// Result for a single option in quadratic voting
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct QuadraticOptionResult {
    /// Sum of sqrt(tokens) across all voters for this option
    pub effective_votes: f64,

    /// Total tokens allocated to this option across all voters
    pub total_tokens: i64,

    /// Number of voters who allocated tokens to this option
    pub voter_count: i64,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ProposalAttachment {
    pub mime_type: Option<String>,

    pub name: String,

    pub size: Option<i64>,

    #[serde(rename = "type")]
    pub proposal_attachment_type: AttachmentType,

    pub url: Option<String>,
}

/// Final result of a completed proposal
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ProposalResult {
    #[serde(rename = "_v")]
    pub v: String,

    pub calculated_at: i64,

    pub outcome: Outcome,

    /// Participation percentage
    pub participation: Option<f64>,

    pub proposal_id: String,

    /// Per-option quadratic voting results (only for quadratic voting proposals)
    pub quadratic_results: Option<HashMap<String, QuadraticResultValue>>,

    pub quorum_met: Option<bool>,

    pub threshold_met: Option<bool>,

    pub total_eligible: Option<i64>,

    pub total_votes: i64,

    /// Vote counts per option
    pub vote_counts: HashMap<String, f64>,

    /// Winning option(s)
    pub winning_options: Option<Vec<String>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub enum Outcome {
    Expired,

    #[serde(rename = "no-quorum")]
    NoQuorum,

    Passed,

    Rejected,

    Tie,
}

/// Result for a single option in quadratic voting
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct QuadraticResultValue {
    /// Sum of sqrt(tokens) across all voters for this option
    pub effective_votes: f64,

    /// Total tokens allocated to this option across all voters
    pub total_tokens: i64,

    /// Number of voters who allocated tokens to this option
    pub voter_count: i64,
}

