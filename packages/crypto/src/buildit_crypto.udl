namespace buildit_crypto {
    // Key derivation
    [Throws=CryptoError]
    sequence<u8> derive_master_key(sequence<u8> password, sequence<u8> salt);

    [Throws=CryptoError]
    sequence<u8> derive_database_key(sequence<u8> master_key);

    [Throws=CryptoError]
    sequence<u8> derive_conversation_key(sequence<u8> private_key, string recipient_pubkey);

    // Key generation
    KeyPair generate_keypair();

    [Throws=CryptoError]
    string get_public_key(sequence<u8> private_key);

    // Schnorr signatures
    [Throws=CryptoError]
    sequence<u8> schnorr_sign(sequence<u8> message, sequence<u8> private_key);

    [Throws=CryptoError]
    boolean schnorr_verify(sequence<u8> message, sequence<u8> signature, sequence<u8> public_key);

    // NIP-44 encryption
    [Throws=CryptoError]
    string nip44_encrypt(sequence<u8> private_key, string recipient_pubkey, string plaintext);

    [Throws=CryptoError]
    string nip44_decrypt(sequence<u8> private_key, string sender_pubkey, string ciphertext);

    // NIP-17 gift wrap
    [Throws=CryptoError]
    NostrEvent create_rumor(
        string sender_pubkey,
        string recipient_pubkey,
        string content,
        i64 created_at
    );

    [Throws=CryptoError]
    NostrEvent create_seal(
        sequence<u8> sender_private_key,
        string recipient_pubkey,
        NostrEvent rumor,
        i64 created_at
    );

    [Throws=CryptoError]
    NostrEvent create_gift_wrap(
        string recipient_pubkey,
        NostrEvent seal,
        i64 created_at
    );

    [Throws=CryptoError]
    UnwrapResult unwrap_gift_wrap(
        sequence<u8> recipient_private_key,
        NostrEvent gift_wrap
    );

    // Nostr events
    [Throws=CryptoError]
    NostrEvent sign_event(sequence<u8> private_key, UnsignedEvent event);

    boolean verify_event(NostrEvent event);

    [Throws=CryptoError]
    string compute_event_id(UnsignedEvent event);

    // AES-GCM for key storage
    [Throws=CryptoError]
    EncryptedData aes_encrypt(sequence<u8> key, sequence<u8> plaintext);

    [Throws=CryptoError]
    sequence<u8> aes_decrypt(sequence<u8> key, EncryptedData encrypted);

    // Duress password system (coercion resistance)
    [Throws=CryptoError]
    sequence<u8> hash_duress_password(sequence<u8> password, sequence<u8> salt);

    [Throws=CryptoError]
    DuressCheckResult check_duress_password(
        sequence<u8> entered_password,
        sequence<u8> salt,
        sequence<u8> stored_duress_hash,
        sequence<u8> stored_normal_hash
    );

    DecoyIdentity generate_decoy_identity(i64 created_at);

    [Throws=CryptoError]
    void secure_destroy_key(sequence<u8> key);

    [Throws=CryptoError]
    NostrEvent create_duress_alert(
        sequence<u8> sender_private_key,
        string recipient_pubkey,
        i64 created_at,
        string? custom_message
    );

    [Throws=CryptoError]
    sequence<NostrEvent> create_duress_alerts(
        sequence<u8> sender_private_key,
        DuressAlertConfig config,
        i64 created_at
    );

    [Throws=CryptoError]
    boolean validate_duress_password(
        sequence<u8> duress_password,
        sequence<u8> normal_password
    );

    sequence<DecoyContact> generate_decoy_contacts(u32 count);

    sequence<string> generate_decoy_messages();

    // Utilities
    sequence<u8> generate_salt(u32 length);

    string bytes_to_hex(sequence<u8> bytes);

    [Throws=CryptoError]
    sequence<u8> hex_to_bytes(string hex_string);

    i64 randomize_timestamp(i64 timestamp, u32 range_seconds);

    // Multi-Sig Threshold Key Management
    [Throws=CryptoError]
    ThresholdKeyGroup generate_threshold_key(ThresholdConfig config);

    [Throws=CryptoError]
    sequence<u8> reconstruct_secret(sequence<KeyShare> shares);

    [Throws=CryptoError]
    PartialSignature sign_with_share(KeyShare share, sequence<u8> message);

    [Throws=CryptoError]
    boolean verify_partial_signature(PartialSignature partial, sequence<u8> message);

    [Throws=CryptoError]
    KeyRotationProposal create_rotation_proposal(
        string group_id,
        KeyShare proposer_share,
        u32 threshold,
        u32 total_shares,
        i64 created_at
    );

    [Throws=CryptoError]
    boolean verify_rotation_proposal(
        KeyRotationProposal proposal,
        string proposer_public_key
    );
};

[Error]
enum CryptoError {
    "InvalidKey",
    "InvalidPublicKey",
    "InvalidSignature",
    "EncryptionFailed",
    "DecryptionFailed",
    "InvalidPlaintextLength",
    "InvalidCiphertext",
    "InvalidPadding",
    "InvalidMac",
    "InvalidHex",
    "InvalidJson",
    "SigningFailed",
    "KeyDerivationFailed",
    "RandomGenerationFailed",
    "InvalidDuressPassword",
    "DuressPasswordTooSimilar",
    "KeyDestructionFailed",
    "DuressAlertFailed",
    "InvalidVersion",
};

dictionary KeyPair {
    sequence<u8> private_key;
    string public_key;
};

dictionary UnsignedEvent {
    string pubkey;
    i64 created_at;
    i32 kind;
    sequence<sequence<string>> tags;
    string content;
};

dictionary NostrEvent {
    string id;
    string pubkey;
    i64 created_at;
    i32 kind;
    sequence<sequence<string>> tags;
    string content;
    string sig;
};

dictionary UnwrapResult {
    NostrEvent rumor;
    string sender_pubkey;
    boolean seal_verified;
};

dictionary EncryptedData {
    sequence<u8> ciphertext;
    sequence<u8> nonce;
};

// Duress password system types
dictionary DecoyIdentity {
    KeyPair keypair;
    string display_name;
    string about;
    i64 created_at;
};

dictionary DuressCheckResult {
    boolean is_duress;
    boolean password_valid;
};

dictionary DuressAlertConfig {
    sequence<string> trusted_contact_pubkeys;
    boolean include_location;
    string? custom_message;
};

dictionary DecoyContact {
    string pubkey;
    string display_name;
};

// Multi-Sig Threshold Key Management types
dictionary ThresholdConfig {
    u32 threshold;
    u32 total_shares;
    string group_name;
};

dictionary KeyShare {
    u32 index;
    sequence<u8> share_secret;
    string share_public_key;
    string group_id;
    u32 total_shares;
    u32 threshold;
};

dictionary ThresholdKeyGroup {
    string group_id;
    string group_public_key;
    sequence<KeyShare> shares;
    u32 threshold;
    u32 total_shares;
};

dictionary PartialSignature {
    u32 signer_index;
    sequence<u8> signature;
    string signer_public_key;
};

dictionary AggregatedSignature {
    sequence<u8> signature;
    string group_public_key;
    sequence<u32> signer_indices;
};

dictionary KeyRotationProposal {
    string proposal_id;
    string group_id;
    string new_group_public_key;
    sequence<KeyShare> new_shares;
    i64 created_at;
    sequence<u8> proposer_signature;
};

// Double Ratchet for Forward Secrecy
dictionary MessageHeader {
    sequence<u8> dh_public_key;
    u32 previous_chain_length;
    u32 message_number;
};

dictionary RatchetMessage {
    MessageHeader header;
    sequence<u8> ciphertext;
    sequence<u8> nonce;
};

interface RatchetSession {
    /// Initialize a new session as Alice (initiator)
    [Throws=CryptoError, Name=initialize_alice]
    constructor(sequence<u8> shared_secret, sequence<u8> bob_public_key);

    /// Initialize a new session as Bob (responder)
    [Throws=CryptoError, Name=initialize_bob]
    constructor(sequence<u8> shared_secret, sequence<u8> our_signed_prekey);

    /// Encrypt a message with forward secrecy
    [Throws=CryptoError]
    RatchetMessage encrypt(sequence<u8> plaintext);

    /// Decrypt a message
    [Throws=CryptoError]
    sequence<u8> decrypt(RatchetMessage message);

    /// Get our current public DH key
    sequence<u8> get_public_key();

    /// Serialize and encrypt session state for safe storage
    [Throws=CryptoError]
    EncryptedData serialize_encrypted(sequence<u8> storage_key);

    /// Decrypt and deserialize session state from storage
    [Throws=CryptoError, Name=deserialize_encrypted]
    constructor(EncryptedData encrypted, sequence<u8> storage_key);
};
