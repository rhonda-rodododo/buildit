# Claude Code Subagents Configuration
# Defines specialized task delegation patterns for autonomous execution

version: 1.0
project: buildit-network

# Subagent Definitions
subagents:

  # Execute complete epics from NEXT_ROADMAP.md
  epic-executor:
    description: "Execute the next epic from NEXT_ROADMAP.md autonomously"
    use_cases:
      - "Complete the next epic from the roadmap"
      - "Execute Epic 28"
      - "Work on Epic 32"

    entry_files:
      - NEXT_ROADMAP.md (identify epic to execute)
      - COMPLETED_ROADMAP.md (understand what's done)
      - ARCHITECTURE.md (system context)
      - ENCRYPTION_STRATEGY.md (if crypto-related)
      - Module-specific files based on epic scope

    execution_process:
      1. Read NEXT_ROADMAP.md and identify target epic
      2. Review epic tasks, dependencies, and acceptance criteria
      3. Check git status to ensure clean working tree
      4. Execute tasks sequentially with TodoWrite tracking
      5. Run tests after each significant change (bun test)
      6. Verify all acceptance criteria met
      7. Run final test suite (bun test, bun run typecheck)
      8. Create git commit with proper format
      9. Update NEXT_ROADMAP.md status if epic incomplete
      10. Move epic to COMPLETED_ROADMAP.md if fully complete

    success_criteria:
      - All epic tasks completed (checkboxes ticked)
      - All acceptance criteria met
      - Tests passing (bun test)
      - TypeScript compilation successful (bun run typecheck)
      - Git commit created with format from epic
      - Documentation updated if required

    testing_requirements:
      - Run unit tests: bun test
      - Run type checking: bun run typecheck
      - Run linting: bun run lint
      - Manual testing as specified in epic

    commit_format:
      - Use exact format specified in epic
      - Example: "feat: complete Epic 28 - Critical Bug Fixes"
      - Include epic number in commit message

    blocked_conditions:
      - Epic has unmet dependencies
      - Build is failing
      - Tests are failing
      - Insufficient context to complete task

  # Fix specific bugs from NEXT_ROADMAP.md or BUGS.md
  bug-fixer:
    description: "Fix specific bugs autonomously"
    use_cases:
      - "Fix BUG-001 from Epic 28"
      - "Resolve the Governance CreateProposalDialog bug"
      - "Fix all integration test failures"

    entry_files:
      - NEXT_ROADMAP.md (Epic 28 contains consolidated bugs)
      - BUGS.md (detailed bug descriptions)
      - Specific file mentioned in bug report
      - Related test files

    execution_process:
      1. Read bug description and impact
      2. Locate affected files
      3. Read surrounding context (imports, related functions)
      4. Identify root cause
      5. Implement fix (avoid workarounds)
      6. Write/update tests to prevent regression
      7. Run affected tests (bun test <file>)
      8. Run full test suite (bun test)
      9. Verify fix with manual testing if specified
      10. Create git commit

    success_criteria:
      - Bug behavior no longer occurs
      - Tests passing (including regression test)
      - No new bugs introduced
      - Root cause addressed (not worked around)
      - TypeScript compilation successful

    testing_requirements:
      - Write regression test if none exists
      - Run affected tests: bun test <file>
      - Run full suite: bun test
      - Manual verification for UI bugs

    commit_format:
      - "fix: resolve <bug-id> - <short description>"
      - Example: "fix: resolve BUG-001 - connect Governance UI to backend"
      - Reference bug ID in commit message

  # Write comprehensive test suites
  test-writer:
    description: "Write unit, integration, or E2E tests"
    use_cases:
      - "Write E2E tests for authentication flow"
      - "Add integration tests for Nostr storage sync"
      - "Write unit tests for new feature X"

    entry_files:
      - NEXT_ROADMAP.md (Epic 29 for E2E tests)
      - Existing test files for patterns
      - Source code being tested
      - Test setup files (vitest.setup.ts, playwright.config.ts)

    execution_process:
      1. Understand feature/module being tested
      2. Review existing test patterns
      3. Identify test scenarios (happy path, edge cases, errors)
      4. Write tests following existing patterns
      5. Use appropriate testing library (Vitest, Playwright, RTL)
      6. Ensure tests are isolated and deterministic
      7. Run tests and fix failures (bun test or bun run test:e2e)
      8. Verify coverage if applicable
      9. Create git commit

    success_criteria:
      - All new tests passing
      - Tests cover happy path and edge cases
      - Tests are deterministic (no flakiness)
      - Code coverage meets targets (>80% for new code)
      - Tests follow project conventions

    testing_requirements:
      - Run unit tests: bun test
      - Run E2E tests: bun run test:e2e
      - Run coverage: bun run test:coverage

    commit_format:
      - "test: add <test-type> tests for <feature>"
      - Example: "test: add E2E tests for authentication flow"
      - Example: "test: add integration tests for Nostr storage sync"

  # Implement new features or modules
  feature-implementer:
    description: "Implement new features or complete modules"
    use_cases:
      - "Implement Documents module (Epic 32)"
      - "Add microblogging feature (Epic 34.1)"
      - "Build form builder component"

    entry_files:
      - NEXT_ROADMAP.md (specific epic)
      - ARCHITECTURE.md (system design)
      - Existing similar modules (for patterns)
      - Library documentation via Context7 MCP

    execution_process:
      1. Read epic/feature specification from NEXT_ROADMAP.md
      2. Review architecture and existing patterns
      3. Use Context7 to fetch latest library documentation
      4. Create/update TypeScript types and interfaces
      5. Implement database schema if needed (Dexie)
      6. Create Zustand store for state management
      7. Build UI components using shadcn/ui
      8. Implement business logic in manager classes
      9. Write comprehensive unit tests
      10. Create seed data for demo/testing
      11. Update module registration if new module
      12. Test thoroughly (bun test + manual)
      13. Update documentation if required
      14. Create git commit

    success_criteria:
      - Feature fully functional per spec
      - All acceptance criteria met
      - Unit tests passing (>80% coverage)
      - TypeScript types comprehensive
      - UI responsive and accessible
      - Seed data demonstrates feature
      - No console errors or warnings

    testing_requirements:
      - Write unit tests for all logic
      - bun test - all tests passing
      - bun run typecheck - no errors
      - Manual testing of UI flows
      - Test on mobile viewport

    commit_format:
      - "feat: implement <feature-name> (<epic-reference>)"
      - Example: "feat: implement Documents module with TipTap (Epic 32)"
      - Example: "feat: add microblogging and activity feed (Epic 34.1-34.2)"

  # Perform security, performance, or accessibility audits
  auditor:
    description: "Perform comprehensive audits of specific types"
    types:
      - security
      - performance
      - accessibility
      - code-quality
      - test-coverage

    use_cases:
      - "Perform security audit for Epic 30"
      - "Run performance audit and identify bottlenecks"
      - "Check accessibility compliance"
      - "Audit test coverage"

    entry_files:
      - Entire codebase for comprehensive audit
      - ARCHITECTURE.md
      - ENCRYPTION_STRATEGY.md (for security audit)
      - PRIVACY.md (for security audit)
      - Build output and bundle analysis

    execution_process:
      1. Identify audit type from user request
      2. Run automated tools (bun audit, Lighthouse, axe, etc.)
      3. Manual code review for audit-specific concerns
      4. Document findings in /docs/audits/<type>-audit-<date>.md
      5. Prioritize issues (critical/high/medium/low)
      6. Create actionable recommendations
      7. Log issues in NEXT_ROADMAP.md backlog if needed
      8. Create summary report

    audit_types:
      security:
        tools:
          - bun audit (dependency vulnerabilities)
          - Manual crypto review (NIP-17, NIP-44)
          - CSP header verification
          - Authentication flow review
        output: /docs/audits/security-audit-<date>.md

      performance:
        tools:
          - Lighthouse performance audit
          - Bundle size analysis (vite-plugin-visualizer)
          - Network tab analysis
          - Memory profiling
        output: /docs/audits/performance-audit-<date>.md

      accessibility:
        tools:
          - axe DevTools
          - Lighthouse accessibility audit
          - Keyboard navigation testing
          - Screen reader testing (manual)
        output: /docs/audits/accessibility-audit-<date>.md

      test-coverage:
        tools:
          - bun run test:coverage
          - Coverage report analysis
          - Integration test gap analysis
        output: /docs/audits/test-coverage-audit-<date>.md

    success_criteria:
      - Audit report created in /docs/audits/
      - All findings documented with severity
      - Recommendations provided for each issue
      - High/critical issues logged in NEXT_ROADMAP.md
      - Report includes summary and action items

    commit_format:
      - "docs: add <audit-type> audit report (<date>)"
      - Example: "docs: add security audit report (2025-10-06)"

  # Optimize performance (bundle size, load time, runtime)
  performance-optimizer:
    description: "Optimize performance metrics and bundle size"
    use_cases:
      - "Reduce bundle size (Epic 35)"
      - "Optimize page load time"
      - "Fix performance issues identified in audit"

    entry_files:
      - NEXT_ROADMAP.md (Epic 35)
      - vite.config.ts
      - Build output and bundle analysis
      - Lighthouse report

    execution_process:
      1. Run bundle analyzer (vite-plugin-visualizer)
      2. Identify large dependencies
      3. Implement code splitting and lazy loading
      4. Optimize vendor chunks
      5. Compress/optimize assets (images, fonts)
      6. Implement tree-shaking improvements
      7. Add resource hints (preconnect, prefetch)
      8. Run Lighthouse before and after
      9. Measure improvement
      10. Create git commit

    success_criteria:
      - Bundle size reduced (target: <300KB gzipped)
      - Lighthouse performance score >90
      - First Contentful Paint <1.5s
      - Time to Interactive <3s
      - No Vite bundle warnings
      - Metrics tracked and documented

    testing_requirements:
      - bun run build - verify build succeeds
      - Run Lighthouse audit
      - Test lazy loading with Network throttling
      - Verify no functionality broken

    commit_format:
      - "perf: <optimization-description>"
      - Example: "perf: implement lazy loading and reduce bundle size to 280KB"

  # Refactor code for better quality/maintainability
  refactorer:
    description: "Refactor code for better structure, types, or patterns"
    use_cases:
      - "Refactor component X to use composition"
      - "Improve TypeScript types in module Y"
      - "Extract shared logic into utility"

    entry_files:
      - Files to be refactored
      - Related test files
      - Architecture documentation

    execution_process:
      1. Understand current implementation
      2. Identify refactoring goal (types, structure, patterns)
      3. Write tests if coverage is low
      4. Perform refactoring incrementally
      5. Run tests after each change (bun test)
      6. Verify no behavior changes
      7. Update documentation if needed
      8. Create git commit

    success_criteria:
      - Code is more maintainable
      - TypeScript types improved (less any, better inference)
      - Tests still passing
      - No behavior changes (unless intended)
      - Code follows project conventions

    testing_requirements:
      - bun test - verify no regressions
      - bun run typecheck - verify type improvements

    commit_format:
      - "refactor: <description>"
      - Example: "refactor: improve TypeScript types in governance module"
      - Example: "refactor: extract shared auth logic to utility"

# Best Practices for Subagent Usage

best_practices:
  always:
    - Read NEXT_ROADMAP.md to understand current priorities
    - Check git status before starting work
    - Use TodoWrite to track epic/task progress
    - Run tests frequently (after each significant change)
    - Use Context7 MCP for latest library documentation
    - Follow existing code patterns and conventions
    - Write comprehensive commit messages
    - Update documentation when adding features

  never:
    - Make workarounds instead of fixing root causes
    - Skip tests ("I'll add them later")
    - Use npm commands (always use bun)
    - Ignore TypeScript errors or add @ts-ignore without good reason
    - Create duplicate files instead of refactoring
    - Commit without running tests
    - Break existing functionality

  when_blocked:
    - Document the blocker clearly
    - Update NEXT_ROADMAP.md with blocker status
    - Suggest next steps or alternatives
    - Ask user for clarification if needed

# Package Manager Configuration

package_manager:
  name: bun
  commands:
    install: "bun install"
    run: "bun run <script>"
    test: "bun test"
    test_e2e: "bun run test:e2e"
    test_coverage: "bun run test:coverage"
    build: "bun run build"
    dev: "bun run dev"
    typecheck: "bun run typecheck"
    lint: "bun run lint"

  notes: "This project uses bun exclusively. Never use npm or yarn commands."

# Git Workflow

git_workflow:
  commit_conventions:
    format: "<type>: <description> (<reference>)"
    types:
      - "feat: New feature"
      - "fix: Bug fix"
      - "docs: Documentation"
      - "test: Tests"
      - "refactor: Code refactoring"
      - "perf: Performance"
      - "chore: Maintenance"
      - "security: Security improvements"

  examples:
    - "feat: implement Documents module with TipTap (Epic 32)"
    - "fix: resolve BUG-001 - connect Governance UI to backend"
    - "test: add E2E tests for authentication flow (Epic 29)"
    - "perf: reduce bundle size with lazy loading (Epic 35)"
    - "docs: add security audit report (2025-10-06)"

  before_commit:
    - Run tests: bun test
    - Check types: bun run typecheck
    - Run linter: bun run lint
    - Review changes: git diff

  commit_message_template: |
    <type>: <description> (<epic/bug reference>)

    - Detailed change 1
    - Detailed change 2

    Closes: <epic-number> or Fixes: <bug-id>

# Context Management

context_loading:
  for_epic_execution:
    essential:
      - NEXT_ROADMAP.md (epic details)
      - COMPLETED_ROADMAP.md (what's done)
      - ARCHITECTURE.md (system design)

    conditional:
      - ENCRYPTION_STRATEGY.md (if crypto-related)
      - PRIVACY.md (if security-related)
      - Module-specific files (based on epic scope)
      - Library docs via Context7 (for dependencies)

  for_bug_fixing:
    essential:
      - NEXT_ROADMAP.md or BUGS.md (bug description)
      - Affected source files
      - Related test files

    conditional:
      - Architecture docs if structural issue
      - Git history: git log <file> (for context)

  for_feature_implementation:
    essential:
      - NEXT_ROADMAP.md (feature spec)
      - ARCHITECTURE.md (patterns)
      - Existing similar modules (for reference)
      - Library docs via Context7

    conditional:
      - ENCRYPTION_STRATEGY.md (if encryption involved)
      - Existing test patterns

# Documentation References

documentation:
  roadmaps:
    next: NEXT_ROADMAP.md
    completed: COMPLETED_ROADMAP.md

  technical:
    architecture: ARCHITECTURE.md
    encryption: ENCRYPTION_STRATEGY.md
    privacy: PRIVACY.md

  project:
    instructions: CLAUDE.md
    index: PRODUCT_INDEX.md
    readme: README.md

  quality:
    bugs: BUGS.md (deprecated - consolidated into NEXT_ROADMAP.md)
    missing_features: MISSING_FEATURES.md (deprecated - consolidated into NEXT_ROADMAP.md)
    audits: /docs/audits/

# Notes

notes: |
  This configuration file enables autonomous execution of development tasks by Claude Code subagents.

  Key principles:
  1. Subagents should be self-contained and autonomous
  2. All necessary context should be fetchable from documented entry files
  3. Success criteria must be objective and testable
  4. Git history should be leveraged for context (use git log, git show)
  5. Always use bun (never npm)

  For parallel sessions with git worktrees, see docs/GIT_WORKFLOW.md
