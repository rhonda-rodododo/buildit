name: Schema Validation

on:
  push:
    paths:
      - 'protocol/schemas/**'
      - 'protocol/test-vectors/**'
      - 'tools/codegen/**'
      - 'tools/schema-bundle/**'
  pull_request:
    paths:
      - 'protocol/schemas/**'
      - 'protocol/test-vectors/**'
      - 'tools/codegen/**'
      - 'tools/schema-bundle/**'

concurrency:
  group: schema-${{ github.ref }}
  cancel-in-progress: true

env:
  BUN_VERSION: "1.1.37"

jobs:
  validate-schemas:
    name: Validate JSON Schemas
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: Cache bun dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            node_modules
          key: bun-root-${{ runner.os }}-${{ hashFiles('bun.lockb', 'package.json') }}
          restore-keys: |
            bun-root-${{ runner.os }}-

      - name: Install dependencies
        run: bun install

      - name: Validate schemas
        working-directory: tools/codegen
        run: bun run validate

      - name: Validate test vectors
        working-directory: tools/codegen
        run: bun run src/index.ts --validate-vectors

  generate-types:
    name: Generate and Verify Types
    runs-on: ubuntu-latest
    needs: validate-schemas
    timeout-minutes: 10

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: Cache bun dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            node_modules
          key: bun-root-${{ runner.os }}-${{ hashFiles('bun.lockb', 'package.json') }}
          restore-keys: |
            bun-root-${{ runner.os }}-

      - name: Install dependencies
        run: bun install

      - name: Generate TypeScript types
        working-directory: tools/codegen
        run: bun run generate:ts

      - name: Check TypeScript compilation
        working-directory: clients/web
        run: bun run typecheck 2>&1 || echo "Type check completed"

      - name: Check for uncommitted codegen drift
        run: |
          if ! git diff --exit-code -- '*.ts' '*.swift' '*.kt'; then
            echo "::warning::Generated types differ from committed versions. Run 'bun run codegen' locally."
            git diff --stat -- '*.ts' '*.swift' '*.kt'
          fi

  validate-bundle:
    name: Validate Schema Bundle
    runs-on: ubuntu-latest
    needs: validate-schemas
    timeout-minutes: 10

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: Cache bun dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            node_modules
          key: bun-root-${{ runner.os }}-${{ hashFiles('bun.lockb', 'package.json') }}
          restore-keys: |
            bun-root-${{ runner.os }}-

      - name: Install dependencies
        run: bun install

      - name: Generate bundle (internal format)
        working-directory: tools/schema-bundle
        run: |
          bun run generate -- --output ./test-bundle.json
          bun run verify -- ./test-bundle.json --allow-any-signer

      - name: Generate bundle (standard format)
        working-directory: tools/schema-bundle
        run: |
          bun run generate:standard -- --output ./test-standard-bundle.json
          bun run verify:standard ./test-standard-bundle.json --allow-any-signer

  registry-consistency:
    name: Check Registry Consistency
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: Verify all modules in registry
        run: |
          # Check that all module directories have entries in registry
          for dir in protocol/schemas/modules/*/; do
            module=$(basename "$dir")
            if [ "$module" != "_registry.json" ]; then
              if ! grep -q "\"$module\"" protocol/schemas/modules/_registry.json; then
                echo "ERROR: Module '$module' not found in _registry.json"
                exit 1
              fi
              echo "OK: Module '$module' found in registry"
            fi
          done

      - name: Verify schema paths exist
        run: |
          # Extract schemaPath values and verify files exist
          node -e "
            const fs = require('fs');
            const registry = JSON.parse(fs.readFileSync('protocol/schemas/modules/_registry.json', 'utf-8'));
            let hasErrors = false;

            for (const [moduleId, metadata] of Object.entries(registry.modules || {})) {
              const schemaPath = 'protocol/schemas/modules/' + metadata.schemaPath;
              if (!fs.existsSync(schemaPath)) {
                console.error('ERROR: Schema file not found:', schemaPath);
                hasErrors = true;
              } else {
                console.log('OK: Found:', schemaPath);
              }
            }

            if (hasErrors) process.exit(1);
          "

      - name: Verify version formats
        run: |
          # Check all version fields are valid semver using fs.readdirSync
          node -e "
            const fs = require('fs');
            const path = require('path');

            function findSchemaFiles(dir) {
              const results = [];
              const entries = fs.readdirSync(dir, { withFileTypes: true });
              for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                if (entry.isDirectory()) {
                  results.push(...findSchemaFiles(fullPath));
                } else if (entry.name.match(/^v\d+\.json$/)) {
                  results.push(fullPath);
                }
              }
              return results;
            }

            const files = findSchemaFiles('protocol/schemas/modules');
            let hasErrors = false;
            const semverRegex = /^\d+\.\d+\.\d+$/;

            for (const file of files) {
              const schema = JSON.parse(fs.readFileSync(file, 'utf-8'));
              if (schema.version && !semverRegex.test(schema.version)) {
                console.error('ERROR: Invalid version in', file, ':', schema.version);
                hasErrors = true;
              }
              if (schema.minReaderVersion && !semverRegex.test(schema.minReaderVersion)) {
                console.error('ERROR: Invalid minReaderVersion in', file, ':', schema.minReaderVersion);
                hasErrors = true;
              }
            }

            if (hasErrors) process.exit(1);
            console.log('OK: All version formats valid (' + files.length + ' schema files checked)');
          "

  cross-version-test-vectors:
    name: Cross-Version Test Vectors
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: Validate cross-version-parsing.json structure
        run: |
          node -e "
            const fs = require('fs');

            // Validate cross-version-parsing.json
            const cvPath = 'protocol/test-vectors/cross-version-parsing.json';
            const cv = JSON.parse(fs.readFileSync(cvPath, 'utf-8'));

            let errors = 0;

            if (!cv.testCases || !Array.isArray(cv.testCases)) {
              console.error('ERROR: cross-version-parsing.json missing testCases array');
              errors++;
            } else {
              console.log('OK: Found ' + cv.testCases.length + ' test cases in cross-version-parsing.json');

              for (const tc of cv.testCases) {
                if (!tc.id || !tc.name || !tc.module || !tc.input || !tc.expected) {
                  console.error('ERROR: Test case missing required fields:', tc.id || 'unknown');
                  errors++;
                }
                if (tc.expected.canParse === undefined) {
                  console.error('ERROR: Test case missing expected.canParse:', tc.id);
                  errors++;
                }
              }
            }

            if (!cv.validationRules || !Array.isArray(cv.validationRules)) {
              console.error('ERROR: Missing validationRules array');
              errors++;
            }

            if (errors > 0) process.exit(1);
            console.log('OK: cross-version-parsing.json structure valid');
          "

      - name: Validate schema-versioning test vectors
        run: |
          node -e "
            const fs = require('fs');
            let errors = 0;

            // Validate bundle-verification.json
            const bvPath = 'protocol/test-vectors/schema-versioning/bundle-verification.json';
            if (!fs.existsSync(bvPath)) {
              console.error('ERROR: Missing ' + bvPath);
              errors++;
            } else {
              const bv = JSON.parse(fs.readFileSync(bvPath, 'utf-8'));
              if (!bv.testSuites || !Array.isArray(bv.testSuites)) {
                console.error('ERROR: bundle-verification.json missing testSuites array');
                errors++;
              } else {
                let totalCases = 0;
                for (const suite of bv.testSuites) {
                  if (!suite.name || !suite.cases || !Array.isArray(suite.cases)) {
                    console.error('ERROR: Test suite missing name or cases:', suite.name || 'unknown');
                    errors++;
                  } else {
                    totalCases += suite.cases.length;
                  }
                }
                console.log('OK: bundle-verification.json has ' + bv.testSuites.length + ' suites, ' + totalCases + ' total cases');
              }
            }

            // Validate version-negotiation.json
            const vnPath = 'protocol/test-vectors/schema-versioning/version-negotiation.json';
            if (!fs.existsSync(vnPath)) {
              console.error('ERROR: Missing ' + vnPath);
              errors++;
            } else {
              const vn = JSON.parse(fs.readFileSync(vnPath, 'utf-8'));
              if (!vn.testSuites || !Array.isArray(vn.testSuites)) {
                console.error('ERROR: version-negotiation.json missing testSuites array');
                errors++;
              } else {
                let totalCases = 0;
                for (const suite of vn.testSuites) {
                  if (!suite.name || !suite.cases || !Array.isArray(suite.cases)) {
                    console.error('ERROR: Test suite missing name or cases:', suite.name || 'unknown');
                    errors++;
                  } else {
                    totalCases += suite.cases.length;
                  }
                }
                console.log('OK: version-negotiation.json has ' + vn.testSuites.length + ' suites, ' + totalCases + ' total cases');
              }
            }

            if (errors > 0) process.exit(1);
            console.log('OK: All schema-versioning test vectors valid');
          "
