/**
 * @generated from protocol/schemas/modules/social-publishing/v1.json
 * @version 1.0.0
 *
 * DO NOT EDIT - This file is auto-generated by tools/codegen
 * Zod validation schemas for the SocialPublishing module
 */

import { z } from "zod";

/** Recurrence rule for scheduled content (iCal-style) */
export const RecurrenceRuleSchema = z.object({
  frequency: z.enum(["daily", "weekly", "monthly"]),
  interval: z.number().int().gte(1).default(1),
  /** Number of occurrences */
  count: z.number().int().gte(1).optional(),
  /** End date as Unix timestamp */
  until: z.number().int().optional(),
  byDay: z.array(z.enum(["MO", "TU", "WE", "TH", "FR", "SA", "SU"])).optional(),
});
export type RecurrenceRule = z.infer<typeof RecurrenceRuleSchema>;

/** Individual platform entry for cross-posting */
export const PlatformPostSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    /** Target platform */
    platform: z.enum(["nostr", "activitypub", "atproto", "rss"]),
    /** Whether to post to this platform */
    enabled: z.boolean(),
    /** Platform-specific content override (e.g., shorter text for Bluesky's 300 char limit) */
    customContent: z.string().max(5000).optional(),
    /** Per-platform publish status */
    status: z.enum(["pending", "published", "failed"]).default("pending"),
    /** URL of the published post on the target platform */
    publishedUrl: z.string().url().max(2048).optional(),
    /** Error details if this platform failed */
    errorMessage: z.string().max(1024).optional(),
  })
  .passthrough();
export type PlatformPost = z.infer<typeof PlatformPostSchema>;

/** Per-scheduled-item cross-posting configuration — which platforms to post to */
export const CrossPostConfigSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    /** Platform-specific post configurations */
    platforms: z.array(PlatformPostSchema).max(10),
  })
  .passthrough();
export type CrossPostConfig = z.infer<typeof CrossPostConfigSchema>;

/** Wraps content from any module with scheduling metadata. The centralized scheduling type — avoids adding scheduledAt to every module's schema. */
export const ScheduledContentSchema = z
  .object({
    /** Schema version that created this content */
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    /** Unique scheduled content identifier */
    id: z.string().uuid(),
    /** Module that owns the content (e.g., 'publishing', 'microblogging', 'events') */
    sourceModule: z.string(),
    /** ID of the content item in the source module */
    sourceContentId: z.string(),
    /** When to publish (Unix timestamp seconds) */
    scheduledAt: z.number().int(),
    /** Current scheduling status */
    status: z
      .enum(["pending", "publishing", "published", "failed", "cancelled"])
      .default("pending"),
    recurrence: RecurrenceRuleSchema.optional(),
    crossPostConfig: CrossPostConfigSchema.optional(),
    /** Pre-signed Nostr event JSON. Client signs, server relays at publish time (zero-knowledge). */
    signedEvent: z.string().max(65536).optional(),
    /** When the content was actually published (Unix timestamp seconds) */
    publishedAt: z.number().int().optional(),
    /** Error details if status is 'failed' */
    errorMessage: z.string().max(1024).optional(),
    /** Number of publish attempts */
    retryCount: z.number().int().gte(0).default(0),
    /** Creator's public key (hex) */
    createdBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    /** Creation timestamp (Unix seconds) */
    createdAt: z.number().int(),
    /** Last update timestamp (Unix seconds) */
    updatedAt: z.number().int().optional(),
  })
  .passthrough();
export type ScheduledContent = z.infer<typeof ScheduledContentSchema>;

/** Connected external social account for cross-posting. Extends federation's FederationIdentity with scheduling metadata. */
export const SocialAccountSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    /** Unique account identifier */
    id: z.string().uuid(),
    /** External platform type */
    platform: z.enum(["activitypub", "atproto"]),
    /** Account handle on the platform (e.g., '@user@mastodon.social' or 'user.bsky.social') */
    handle: z.string().max(256),
    /** Display name on the external platform */
    displayName: z.string().max(128).optional(),
    /** Avatar URL on the external platform */
    avatarUrl: z.string().url().max(2048).optional(),
    /** Associated Nostr pubkey */
    pubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    /** Whether the account is currently connected and usable */
    isActive: z.boolean().default(true),
    /** Last time the account status was verified */
    lastSyncAt: z.number().int().optional(),
    /** When the account was connected (Unix seconds) */
    createdAt: z.number().int(),
  })
  .passthrough();
export type SocialAccount = z.infer<typeof SocialAccountSchema>;

/** Custom SEO metadata overrides for share links and content */
export const SEOOverridesSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")).optional(),
    /** Custom meta title */
    title: z.string().max(70).optional(),
    /** Custom meta description */
    description: z.string().max(160).optional(),
    /** Custom OG image URL (overrides auto-generated) */
    ogImageUrl: z.string().url().max(2048).optional(),
    /** SEO keywords */
    keywords: z.array(z.string().max(50)).max(20).optional(),
    /** Custom canonical URL */
    canonicalUrl: z.string().url().max(2048).optional(),
  })
  .passthrough();
export type SEOOverrides = z.infer<typeof SEOOverridesSchema>;

/** Generated public share URL with optional password, expiration, and click tracking */
export const ShareLinkSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    /** Unique share link identifier */
    id: z.string().uuid(),
    /** Short URL slug (nanoid-based, 8 chars default) */
    slug: z.string().regex(new RegExp("^[a-zA-Z0-9_-]{4,32}$")),
    /** Module that owns the shared content */
    sourceModule: z.string(),
    /** ID of the content item in the source module */
    sourceContentId: z.string(),
    /** Full URL the share link resolves to */
    targetUrl: z.string().max(2048).optional(),
    /** Optional expiration (Unix timestamp seconds) */
    expiresAt: z.number().int().optional(),
    /** Optional Argon2id hash of access password */
    passwordHash: z.string().optional(),
    /** Whether to record privacy-preserving click analytics */
    trackClicks: z.boolean().default(true),
    /** Total click count */
    clickCount: z.number().int().gte(0).default(0),
    seoOverrides: SEOOverridesSchema.optional(),
    /** Whether the share link is active */
    isActive: z.boolean().default(true),
    /** Creator's public key (hex) */
    createdBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    /** Creation timestamp (Unix seconds) */
    createdAt: z.number().int(),
  })
  .passthrough();
export type ShareLink = z.infer<typeof ShareLinkSchema>;

/** Denormalized view entry for the content calendar aggregation */
export const ContentCalendarEntrySchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    /** Calendar entry identifier */
    id: z.string().uuid(),
    /** Originating module */
    sourceModule: z.string(),
    /** Content item ID in the source module */
    sourceContentId: z.string(),
    /** Content title for calendar display */
    title: z.string().max(256),
    /** Scheduled time (Unix timestamp seconds) */
    scheduledAt: z.number().int(),
    /** Publishing status */
    status: z.enum([
      "pending",
      "publishing",
      "published",
      "failed",
      "cancelled",
    ]),
    /** Target platforms for this content */
    platforms: z
      .array(z.enum(["nostr", "activitypub", "atproto", "rss"]))
      .optional(),
    /** Type of content for color-coding */
    contentType: z
      .enum(["article", "post", "event", "newsletter", "listing"])
      .optional(),
  })
  .passthrough();
export type ContentCalendarEntry = z.infer<typeof ContentCalendarEntrySchema>;

/** Privacy-preserving per-share analytics. Session-based, no user identification, no cookies. */
export const OutreachAnalyticsSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    /** Unique analytics entry identifier */
    id: z.string().uuid(),
    /** Share link that was clicked */
    shareLinkId: z.string().uuid(),
    /** Random session identifier (not tied to user identity) */
    sessionId: z.string(),
    /** Click timestamp (Unix seconds) */
    timestamp: z.number().int(),
    /** Referring domain (stripped to domain only for privacy) */
    referrer: z.string().max(512).optional(),
    /** Detected platform (e.g., 'mastodon', 'bluesky', 'twitter', 'email', 'direct') */
    platform: z.string().max(64).optional(),
  })
  .passthrough();
export type OutreachAnalytics = z.infer<typeof OutreachAnalyticsSchema>;

/** Module version */
export const SOCIAL_PUBLISHING_SCHEMA_VERSION = "1.0.0" as const;
