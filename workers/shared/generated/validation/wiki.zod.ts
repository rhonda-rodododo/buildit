/**
 * @generated from protocol/schemas/modules/wiki/v1.json
 * @version 1.0.0
 *
 * DO NOT EDIT - This file is auto-generated by tools/codegen
 * Zod validation schemas for the Wiki module
 */

import { z } from "zod";

/** Current status of the page */
export const PageStatusSchema = z.enum([
  "draft",
  "review",
  "published",
  "archived",
  "deleted",
]);
export type PageStatus = z.infer<typeof PageStatusSchema>;

/** Who can view this page */
export const PageVisibilitySchema = z
  .enum(["public", "group", "private", "role-restricted"])
  .default("group");
export type PageVisibility = z.infer<typeof PageVisibilitySchema>;

export const PagePermissionsSchema = z.object({
  /** Roles that can edit this page */
  editRoles: z.array(z.string()).optional(),
  /** Roles that can view this page (for role-restricted) */
  viewRoles: z.array(z.string()).optional(),
  allowComments: z.boolean().default(true),
  allowSuggestions: z.boolean().default(true),
});
export type PagePermissions = z.infer<typeof PagePermissionsSchema>;

/** A wiki page in the knowledge base */
export const WikiPageSchema = z.object({
  /** Schema version for graceful degradation */
  _v: z.string().default("1.0.0"),
  /** Unique identifier for the page */
  id: z.string().uuid(),
  /** Group this page belongs to */
  groupId: z.string().uuid(),
  /** URL-friendly identifier */
  slug: z.string().regex(new RegExp("^[a-z0-9-]+$")).max(200),
  /** Page title */
  title: z.string().min(1).max(200),
  /** Page content in markdown */
  content: z.string(),
  /** Brief summary for search results and previews */
  summary: z.string().max(500).optional(),
  /** Current version number of the page */
  version: z.number().int().gte(1),
  /** Parent page for hierarchical organization */
  parentId: z.string().uuid().optional(),
  /** Category this page belongs to */
  categoryId: z.string().uuid().optional(),
  status: PageStatusSchema,
  visibility: PageVisibilitySchema.optional(),
  permissions: PagePermissionsSchema.optional(),
  /** Categorization tags */
  tags: z.array(z.string()).optional(),
  /** Alternative slugs that redirect to this page */
  aliases: z.array(z.string()).optional(),
  /** Public key of the original creator */
  createdBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
  /** Public key of the last editor */
  lastEditedBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")).optional(),
  /** All contributors to this page */
  contributors: z
    .array(z.string().regex(new RegExp("^[0-9a-f]{64}$")))
    .optional(),
  /** User who has the page locked for editing */
  lockedBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")).optional(),
  /** Timestamp when page was locked */
  lockedAt: z.number().int().optional(),
  /** Unix timestamp of creation */
  createdAt: z.number().int(),
  /** Unix timestamp of last update */
  updatedAt: z.number().int().optional(),
  /** Unix timestamp when page was published */
  publishedAt: z.number().int().optional(),
  /** Unix timestamp when page was archived */
  archivedAt: z.number().int().optional(),
  /** Unix timestamp for soft delete */
  deletedAt: z.number().int().optional(),
  /** Custom metadata fields */
  metadata: z.record(z.string(), z.any()).optional(),
});
export type WikiPage = z.infer<typeof WikiPageSchema>;

/** A historical revision of a wiki page */
export const PageRevisionSchema = z.object({
  _v: z.string().default("1.0.0"),
  id: z.string().uuid(),
  pageId: z.string().uuid(),
  version: z.number().int().gte(1),
  title: z.string().optional(),
  content: z.string(),
  /** Edit summary describing the changes */
  summary: z.string().optional(),
  /** Unified diff from previous version */
  diff: z.string().optional(),
  editedBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
  editType: z
    .enum(["create", "edit", "revert", "merge", "move"])
    .default("edit"),
  /** Version number if this is a revert */
  revertedFrom: z.number().int().optional(),
  createdAt: z.number().int(),
});
export type PageRevision = z.infer<typeof PageRevisionSchema>;

/** A category for organizing wiki pages */
export const WikiCategorySchema = z.object({
  _v: z.string().default("1.0.0"),
  id: z.string().uuid(),
  groupId: z.string().uuid(),
  name: z.string().min(1).max(100),
  slug: z.string().regex(new RegExp("^[a-z0-9-]+$")),
  description: z.string().optional(),
  /** Parent category for hierarchical organization */
  parentId: z.string().uuid().optional(),
  /** Icon identifier */
  icon: z.string().optional(),
  /** Display color */
  color: z.string().optional(),
  /** Display order */
  order: z.number().int().optional(),
  /** Number of pages in this category */
  pageCount: z.number().int().gte(0).optional(),
  createdBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
  createdAt: z.number().int(),
  updatedAt: z.number().int().optional(),
});
export type WikiCategory = z.infer<typeof WikiCategorySchema>;

/** A link between wiki pages */
export const WikiLinkSchema = z.object({
  _v: z.string().default("1.0.0"),
  sourcePageId: z.string().uuid(),
  targetPageId: z.string().uuid().optional(),
  /** Slug of target page (for broken link detection) */
  targetSlug: z.string(),
  /** Text around the link for context */
  context: z.string().optional(),
  /** Whether target page exists */
  isBroken: z.boolean().default(false),
  createdAt: z.number().int(),
});
export type WikiLink = z.infer<typeof WikiLinkSchema>;

/** A comment on a wiki page */
export const PageCommentSchema = z.object({
  _v: z.string().default("1.0.0"),
  id: z.string().uuid(),
  pageId: z.string().uuid(),
  /** Parent comment for threaded replies */
  parentId: z.string().uuid().optional(),
  content: z.string(),
  authorId: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
  /** Whether this comment thread is resolved */
  resolved: z.boolean().default(false),
  resolvedBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")).optional(),
  resolvedAt: z.number().int().optional(),
  editedAt: z.number().int().optional(),
  createdAt: z.number().int(),
  deletedAt: z.number().int().optional(),
});
export type PageComment = z.infer<typeof PageCommentSchema>;

/** A suggested edit to a wiki page */
export const EditSuggestionSchema = z.object({
  _v: z.string().default("1.0.0"),
  id: z.string().uuid(),
  pageId: z.string().uuid(),
  /** Version this suggestion is based on */
  baseVersion: z.number().int(),
  /** Suggested title (if changed) */
  title: z.string().optional(),
  /** Suggested content */
  content: z.string(),
  /** Description of the suggested changes */
  summary: z.string().optional(),
  /** Unified diff showing changes */
  diff: z.string().optional(),
  suggestedBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
  status: z
    .enum(["pending", "approved", "rejected", "merged", "superseded"])
    .default("pending"),
  reviewedBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")).optional(),
  reviewedAt: z.number().int().optional(),
  reviewComment: z.string().optional(),
  createdAt: z.number().int(),
});
export type EditSuggestion = z.infer<typeof EditSuggestionSchema>;

/** Search result from the wiki */
export const WikiSearchSchema = z.object({
  _v: z.string().default("1.0.0"),
  pageId: z.string().uuid(),
  title: z.string(),
  slug: z.string(),
  summary: z.string().optional(),
  /** Relevant excerpt with search terms highlighted */
  excerpt: z.string().optional(),
  /** Search relevance score */
  score: z.number(),
  matchedTags: z.array(z.string()).optional(),
  categoryName: z.string().optional(),
  updatedAt: z.number().int().optional(),
});
export type WikiSearch = z.infer<typeof WikiSearchSchema>;

/** Module version */
export const WIKI_SCHEMA_VERSION = "1.0.0" as const;
