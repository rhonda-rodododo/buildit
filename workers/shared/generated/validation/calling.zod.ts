/**
 * @generated from protocol/schemas/modules/calling/v1.json
 * @version 1.0.0
 *
 * DO NOT EDIT - This file is auto-generated by tools/codegen
 * Zod validation schemas for the Calling module
 */

import { z } from "zod";

/** Caller capabilities */
export const CallCapabilitiesSchema = z
  .object({
    video: z.boolean().optional(),
    screenShare: z.boolean().optional(),
    e2ee: z.boolean().default(true),
    insertableStreams: z.boolean().optional(),
  })
  .passthrough();
export type CallCapabilities = z.infer<typeof CallCapabilitiesSchema>;

/** WebRTC call offer with SDP (wrapped in NIP-17) */
export const CallOfferSchema = z
  .object({
    /** Schema version */
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    /** Unique identifier for this call session */
    callId: z.string().uuid(),
    /** SDP offer (Session Description Protocol) */
    sdp: z.string(),
    /** Type of call being initiated */
    callType: z.enum(["voice", "video"]),
    /** Unix timestamp of offer creation */
    timestamp: z.number().int(),
    /** Optional group context for the call */
    groupId: z.string().optional(),
    /** Hotline ID if calling a hotline */
    hotlineId: z.string().optional(),
    /** Group call room ID for mesh/SFU */
    roomId: z.string().optional(),
    /** True if this is a reconnection attempt */
    isReconnect: z.boolean().optional(),
    /** True if adding/removing tracks mid-call */
    isRenegotiation: z.boolean().optional(),
    capabilities: CallCapabilitiesSchema.optional(),
  })
  .passthrough();
export type CallOffer = z.infer<typeof CallOfferSchema>;

/** WebRTC call answer with SDP */
export const CallAnswerSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    callId: z.string().uuid(),
    /** SDP answer */
    sdp: z.string(),
    timestamp: z.number().int(),
  })
  .passthrough();
export type CallAnswer = z.infer<typeof CallAnswerSchema>;

/** ICE candidate for connection negotiation */
export const CallIceCandidateSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    callId: z.string().uuid(),
    /** RTCIceCandidate serialized */
    candidate: z.object({
      candidate: z.string().optional(),
      sdpMid: z.string().optional(),
      sdpMLineIndex: z.number().int().optional(),
      usernameFragment: z.string().optional(),
    }),
  })
  .passthrough();
export type CallIceCandidate = z.infer<typeof CallIceCandidateSchema>;

/** Call termination signal */
export const CallHangupSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    callId: z.string().uuid(),
    /** Reason for call termination */
    reason: z.enum([
      "completed",
      "rejected",
      "busy",
      "no_answer",
      "network_failure",
      "cancelled",
      "timeout",
    ]),
    timestamp: z.number().int().optional(),
  })
  .passthrough();
export type CallHangup = z.infer<typeof CallHangupSchema>;

/** Call quality metrics */
export const CallQualitySchema = z
  .object({
    /** Percentage 0-100 */
    packetLoss: z.number().optional(),
    /** Milliseconds */
    jitter: z.number().optional(),
    /** Milliseconds */
    roundTripTime: z.number().optional(),
    /** Bits per second */
    bandwidth: z.number().int().optional(),
    /** 0-1 normalized */
    audioLevel: z.number().optional(),
  })
  .passthrough();
export type CallQuality = z.infer<typeof CallQualitySchema>;

/** Local call state tracking */
export const CallStateSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    callId: z.string().uuid(),
    state: z.enum([
      "initiating",
      "ringing",
      "connecting",
      "connected",
      "on_hold",
      "reconnecting",
      "ended",
    ]),
    direction: z.enum(["outgoing", "incoming"]),
    callType: z.enum(["voice", "video"]).optional(),
    /** Nostr pubkey of the other party */
    remotePubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    /** Display name of remote party */
    remoteName: z.string().optional(),
    /** Unix timestamp when call was initiated */
    startedAt: z.number().int(),
    /** Unix timestamp when call connected */
    connectedAt: z.number().int().optional(),
    /** Unix timestamp when call ended */
    endedAt: z.number().int().optional(),
    endReason: z
      .enum([
        "completed",
        "rejected",
        "busy",
        "no_answer",
        "network_failure",
        "cancelled",
        "timeout",
      ])
      .optional(),
    isEncrypted: z.boolean().default(true),
    isMuted: z.boolean().optional(),
    isVideoEnabled: z.boolean().optional(),
    isScreenSharing: z.boolean().optional(),
    quality: CallQualitySchema.optional(),
  })
  .passthrough();
export type CallState = z.infer<typeof CallStateSchema>;

/** Create a new group call room */
export const GroupCallCreateSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    roomId: z.string().uuid(),
    /** BuildIt group context */
    groupId: z.string().optional(),
    callType: z.enum(["voice", "video"]),
    topology: z.enum(["mesh", "sfu"]).default("mesh"),
    maxParticipants: z.number().int().gte(2).lte(100).default(8),
    createdBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    invitedPubkeys: z
      .array(z.string().regex(new RegExp("^[0-9a-f]{64}$")))
      .optional(),
    timestamp: z.number().int(),
  })
  .passthrough();
export type GroupCallCreate = z.infer<typeof GroupCallCreateSchema>;

/** Join an existing group call */
export const GroupCallJoinSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    roomId: z.string().uuid(),
    pubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    displayName: z.string().optional(),
    timestamp: z.number().int(),
  })
  .passthrough();
export type GroupCallJoin = z.infer<typeof GroupCallJoinSchema>;

/** Leave a group call */
export const GroupCallLeaveSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    roomId: z.string().uuid(),
    pubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    timestamp: z.number().int(),
  })
  .passthrough();
export type GroupCallLeave = z.infer<typeof GroupCallLeaveSchema>;

/** Participant in a group call */
export const GroupCallParticipantSchema = z
  .object({
    pubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    displayName: z.string().optional(),
    joinedAt: z.number().int(),
    state: z.enum(["connecting", "connected", "reconnecting", "left"]),
    audioEnabled: z.boolean().optional(),
    videoEnabled: z.boolean().optional(),
    screenSharing: z.boolean().optional(),
    isHost: z.boolean().optional(),
    isSpeaking: z.boolean().optional(),
  })
  .passthrough();
export type GroupCallParticipant = z.infer<typeof GroupCallParticipantSchema>;

/** Distribute sender key for group E2EE */
export const SenderKeyDistributionSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    roomId: z.string().uuid(),
    senderPubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    /** Key ID for rotation tracking */
    keyId: z.number().int(),
    /** Map of recipient pubkey to NIP-44 encrypted key */
    encryptedKeys: z.record(z.string(), z.string()),
    timestamp: z.number().int().optional(),
  })
  .passthrough();
export type SenderKeyDistribution = z.infer<typeof SenderKeyDistributionSchema>;

/** Persistent call log entry */
export const CallHistorySchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    callId: z.string().uuid(),
    remotePubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    remoteName: z.string().optional(),
    direction: z.enum(["outgoing", "incoming"]),
    callType: z.enum(["voice", "video", "group"]).optional(),
    startedAt: z.number().int(),
    connectedAt: z.number().int().optional(),
    endedAt: z.number().int().optional(),
    /** Duration in seconds */
    duration: z.number().int().optional(),
    endReason: z
      .enum([
        "completed",
        "rejected",
        "busy",
        "no_answer",
        "network_failure",
        "cancelled",
        "timeout",
      ])
      .optional(),
    wasEncrypted: z.boolean().optional(),
    groupId: z.string().optional(),
    roomId: z.string().optional(),
    /** For group calls */
    participantCount: z.number().int().optional(),
  })
  .passthrough();
export type CallHistory = z.infer<typeof CallHistorySchema>;

/** User call preferences */
export const CallSettingsSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")).optional(),
    defaultCallType: z.enum(["voice", "video"]).default("voice"),
    autoAnswer: z.boolean().default(false),
    doNotDisturb: z.boolean().default(false),
    allowUnknownCallers: z.boolean().default(true),
    /** Always use TURN relay for privacy */
    relayOnlyMode: z.boolean().default(false),
    preferredAudioInput: z.string().optional(),
    preferredAudioOutput: z.string().optional(),
    preferredVideoInput: z.string().optional(),
    echoCancellation: z.boolean().default(true),
    noiseSuppression: z.boolean().default(true),
    autoGainControl: z.boolean().default(true),
  })
  .passthrough();
export type CallSettings = z.infer<typeof CallSettingsSchema>;

/** Extended call state for hotline calls */
export const HotlineCallStateSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    callId: z.string().uuid(),
    hotlineId: z.string(),
    groupId: z.string().optional(),
    callType: z.enum(["internal", "pstn"]),
    state: z.enum([
      "queued",
      "ringing",
      "active",
      "on_hold",
      "completed",
      "escalated",
      "transferred",
      "abandoned",
    ]),
    priority: z.enum(["low", "medium", "high", "urgent"]).default("medium"),
    caller: z
      .object({
        pubkey: z.string().optional(),
        phone: z.string().optional(),
        name: z.string().optional(),
      })
      .optional(),
    operator: z
      .object({ pubkey: z.string().optional(), name: z.string().optional() })
      .optional(),
    queuePosition: z.number().int().optional(),
    queuedAt: z.number().int().optional(),
    answeredAt: z.number().int().optional(),
    endedAt: z.number().int().optional(),
    /** Seconds in queue */
    waitDuration: z.number().int().optional(),
    notes: z.string().optional(),
    category: z.string().optional(),
    isEncrypted: z.boolean().optional(),
  })
  .passthrough();
export type HotlineCallState = z.infer<typeof HotlineCallStateSchema>;

/** Operator availability status */
export const HotlineOperatorStatusSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    pubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    hotlineId: z.string(),
    status: z.enum(["available", "on_call", "wrap_up", "break", "offline"]),
    currentCallId: z.string().optional(),
    shiftStart: z.number().int().optional(),
    shiftEnd: z.number().int().optional(),
    callCount: z.number().int().optional(),
    timestamp: z.number().int().optional(),
  })
  .passthrough();
export type HotlineOperatorStatus = z.infer<typeof HotlineOperatorStatusSchema>;

/** Current queue status for a hotline */
export const HotlineQueueStateSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    hotlineId: z.string(),
    calls: z.array(
      z.object({
        callId: z.string().optional(),
        callerName: z.string().optional(),
        priority: z.string().optional(),
        queuedAt: z.number().int().optional(),
        position: z.number().int().optional(),
      }),
    ),
    operatorsAvailable: z.number().int().optional(),
    /** Seconds */
    estimatedWaitTime: z.number().int().optional(),
    timestamp: z.number().int().optional(),
  })
  .passthrough();
export type HotlineQueueState = z.infer<typeof HotlineQueueStateSchema>;

/** Text-based hotline conversation thread */
export const MessagingHotlineThreadSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    threadId: z.string().uuid(),
    hotlineId: z.string(),
    groupId: z.string().optional(),
    contact: z
      .object({
        pubkey: z.string().optional(),
        phone: z.string().optional(),
        name: z.string().optional(),
        type: z.enum(["buildit", "sms", "rcs"]).optional(),
      })
      .optional(),
    assignedOperator: z.string().regex(new RegExp("^[0-9a-f]{64}$")).optional(),
    status: z.enum([
      "unassigned",
      "assigned",
      "active",
      "waiting",
      "resolved",
      "archived",
    ]),
    priority: z.enum(["low", "medium", "high", "urgent"]).default("medium"),
    category: z.string().optional(),
    messageCount: z.number().int().optional(),
    lastMessageAt: z.number().int().optional(),
    lastMessageBy: z.enum(["contact", "operator"]).optional(),
    unreadByOperator: z.number().int().optional(),
    createdAt: z.number().int(),
    resolvedAt: z.number().int().optional(),
    /** If escalated to voice */
    linkedCallId: z.string().optional(),
  })
  .passthrough();
export type MessagingHotlineThread = z.infer<
  typeof MessagingHotlineThreadSchema
>;

/** Message broadcast/blast */
export const BroadcastSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    broadcastId: z.string().uuid(),
    title: z.string().optional(),
    content: z.string().max(10000),
    targetType: z.enum([
      "group",
      "contact_list",
      "public_channel",
      "emergency",
    ]),
    targetIds: z.array(z.string()).optional(),
    priority: z.enum(["normal", "high", "emergency"]).default("normal"),
    createdBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    scheduledAt: z.number().int().optional(),
    sentAt: z.number().int().optional(),
    status: z
      .enum(["draft", "scheduled", "sending", "sent", "failed"])
      .optional(),
    analytics: z
      .object({
        totalRecipients: z.number().int().optional(),
        delivered: z.number().int().optional(),
        read: z.number().int().optional(),
        replied: z.number().int().optional(),
      })
      .optional(),
  })
  .passthrough();
export type Broadcast = z.infer<typeof BroadcastSchema>;

/** SFU-based conference room */
export const ConferenceRoomSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    roomId: z.string().uuid(),
    groupId: z.string().optional(),
    name: z.string(),
    sfuEndpoint: z.string().url().optional(),
    maxParticipants: z.number().int().default(100),
    createdBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    settings: z
      .object({
        waitingRoom: z.boolean().optional(),
        allowScreenShare: z.boolean().optional(),
        allowRecording: z.boolean().optional(),
        locked: z.boolean().optional(),
        e2eeRequired: z.boolean().default(true),
      })
      .optional(),
    createdAt: z.number().int().optional(),
    expiresAt: z.number().int().optional(),
  })
  .passthrough();
export type ConferenceRoom = z.infer<typeof ConferenceRoomSchema>;

/** Breakout room configuration */
export const BreakoutConfigSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    mainRoomId: z.string().uuid(),
    breakouts: z.array(
      z.object({
        id: z.string().uuid(),
        name: z.string(),
        participants: z.array(z.string()).optional(),
        capacity: z.number().int().optional(),
      }),
    ),
    /** Seconds, 0 for unlimited */
    duration: z.number().int().optional(),
    autoAssign: z.boolean().optional(),
    allowSelfSelect: z.boolean().optional(),
    createdBy: z.string().optional(),
    createdAt: z.number().int().optional(),
  })
  .passthrough();
export type BreakoutConfig = z.infer<typeof BreakoutConfigSchema>;

/** Participant in an SFU conference */
export const ConferenceParticipantSchema = z
  .object({
    pubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    displayName: z.string().optional(),
    joinedAt: z.number().int(),
    role: z.enum(["host", "co_host", "moderator", "participant", "viewer"]),
    audioEnabled: z.boolean().optional(),
    videoEnabled: z.boolean().optional(),
    screenSharing: z.boolean().optional(),
    handRaised: z.boolean().optional(),
    inWaitingRoom: z.boolean().optional(),
    /** Breakout room ID if in breakout */
    inBreakout: z.string().optional(),
  })
  .passthrough();
export type ConferenceParticipant = z.infer<typeof ConferenceParticipantSchema>;

/** MLS welcome message for new participants */
export const MLSWelcomeSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    roomId: z.string().uuid(),
    targetPubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    /** Base64-encoded encrypted MLS welcome message */
    welcome: z.string(),
    epoch: z.number().int().optional(),
    timestamp: z.number().int().optional(),
  })
  .passthrough();
export type MLSWelcome = z.infer<typeof MLSWelcomeSchema>;

/** MLS commit for key rotation */
export const MLSCommitSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    roomId: z.string().uuid(),
    epoch: z.number().int(),
    /** Base64-encoded MLS commit message */
    commit: z.string(),
    senderPubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")).optional(),
    timestamp: z.number().int().optional(),
  })
  .passthrough();
export type MLSCommit = z.infer<typeof MLSCommitSchema>;

/** Participant waiting to join conference */
export const WaitingRoomParticipantSchema = z
  .object({
    pubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    displayName: z.string().optional(),
    joinedAt: z.number().int(),
  })
  .passthrough();
export type WaitingRoomParticipant = z.infer<
  typeof WaitingRoomParticipantSchema
>;

/** Hand raise event */
export const HandRaiseSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    roomId: z.string().uuid(),
    pubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    action: z.enum(["raise", "lower"]),
    timestamp: z.number().int().optional(),
  })
  .passthrough();
export type HandRaise = z.infer<typeof HandRaiseSchema>;

/** Emoji reaction in conference */
export const ReactionSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    roomId: z.string().uuid(),
    pubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    emoji: z.enum(["üëç", "üëé", "‚ù§Ô∏è", "üòÇ", "üòÆ", "üéâ", "üëè", "‚úã"]),
    timestamp: z.number().int().optional(),
  })
  .passthrough();
export type Reaction = z.infer<typeof ReactionSchema>;

/** Conference poll */
export const PollSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    pollId: z.string().uuid(),
    roomId: z.string().uuid(),
    question: z.string(),
    options: z.array(z.string()),
    createdBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    status: z.enum(["draft", "active", "closed"]).optional(),
    settings: z
      .object({
        anonymous: z.boolean().optional(),
        multiSelect: z.boolean().optional(),
        showLiveResults: z.boolean().optional(),
      })
      .optional(),
    results: z
      .array(
        z.object({
          option: z.string().optional(),
          count: z.number().int().optional(),
        }),
      )
      .optional(),
    createdAt: z.number().int().optional(),
    closedAt: z.number().int().optional(),
  })
  .passthrough();
export type Poll = z.infer<typeof PollSchema>;

/** Vote on a poll */
export const PollVoteSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    pollId: z.string().uuid(),
    roomId: z.string().uuid(),
    /** Encrypted vote with voter token for anonymity */
    encryptedVote: z.string(),
    /** HMAC(roomId + pollId, privateKey) for anonymous deduplication */
    voterToken: z.string().optional(),
    timestamp: z.number().int().optional(),
  })
  .passthrough();
export type PollVote = z.infer<typeof PollVoteSchema>;

/** Recording consent from participant */
export const RecordingConsentSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    roomId: z.string().uuid(),
    pubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    consented: z.boolean(),
    timestamp: z.number().int().optional(),
  })
  .passthrough();
export type RecordingConsent = z.infer<typeof RecordingConsentSchema>;

/** In-conference chat message */
export const ConferenceChatMessageSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    messageId: z.string().uuid(),
    roomId: z.string().uuid(),
    senderPubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    content: z.string(),
    recipientType: z.enum(["everyone", "host", "private"]).default("everyone"),
    /** For private messages */
    recipientPubkey: z.string().optional(),
    timestamp: z.number().int().optional(),
  })
  .passthrough();
export type ConferenceChatMessage = z.infer<typeof ConferenceChatMessageSchema>;

/** PSTN call state */
export const PSTNCallSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    /** Twilio call SID */
    callSid: z.string(),
    hotlineId: z.string(),
    direction: z.enum(["inbound", "outbound"]),
    /** Masked phone number */
    callerPhone: z.string().optional(),
    targetPhone: z.string().optional(),
    operatorPubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")).optional(),
    status: z.enum([
      "queued",
      "ringing",
      "connected",
      "on_hold",
      "completed",
      "failed",
    ]),
    startedAt: z.number().int().optional(),
    connectedAt: z.number().int().optional(),
    endedAt: z.number().int().optional(),
    /** Duration in seconds */
    duration: z.number().int().optional(),
    /** Credits used for this call */
    creditsCost: z.number().optional(),
  })
  .passthrough();
export type PSTNCall = z.infer<typeof PSTNCallSchema>;

/** PSTN credit balance for a group */
export const CreditBalanceSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    groupId: z.string().uuid(),
    monthlyAllocation: z.number(),
    used: z.number(),
    remaining: z.number(),
    /** Unix timestamp of next reset */
    resetDate: z.number().int().optional(),
  })
  .passthrough();
export type CreditBalance = z.infer<typeof CreditBalanceSchema>;

/** Module version */
export const CALLING_SCHEMA_VERSION = "1.0.0" as const;
