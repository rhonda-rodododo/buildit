/**
 * @generated from protocol/schemas/modules/events/v1.json
 * @version 1.0.0
 *
 * DO NOT EDIT - This file is auto-generated by tools/codegen
 * Zod validation schemas for the Events module
 */

import { z } from "zod";

/** Physical location for an event */
export const LocationSchema = z.object({
  /** Location name */
  name: z.string().max(256).optional(),
  /** Street address */
  address: z.string().max(512).optional(),
  /** [latitude, longitude] */
  coordinates: z.array(z.number()).min(2).max(2).optional(),
  /** Access instructions */
  instructions: z.string().max(1024).optional(),
});
export type Location = z.infer<typeof LocationSchema>;

/** iCal-style recurrence rule */
export const RecurrenceRuleSchema = z.object({
  frequency: z.enum(["daily", "weekly", "monthly", "yearly"]),
  interval: z.number().int().gte(1).default(1),
  /** Number of occurrences */
  count: z.number().int().gte(1).optional(),
  /** End date as Unix timestamp */
  until: z.number().int().optional(),
  byDay: z.array(z.enum(["MO", "TU", "WE", "TH", "FR", "SA", "SU"])).optional(),
});
export type RecurrenceRule = z.infer<typeof RecurrenceRuleSchema>;

export const AttachmentSchema = z.object({
  type: z.enum(["image", "file", "link"]),
  url: z.string().url().max(2048),
  name: z.string().max(256).optional(),
  mimeType: z.string().optional(),
  /** File size in bytes */
  size: z.number().int().optional(),
});
export type Attachment = z.infer<typeof AttachmentSchema>;

/** An event with time, location, and RSVP tracking */
export const EventSchema = z
  .object({
    /** Schema version that created this content */
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    /** Unique event identifier */
    id: z.string().uuid(),
    /** Event title */
    title: z.string().max(256),
    /** Event description (markdown supported) */
    description: z.string().max(8192).optional(),
    /** Start time as Unix timestamp (seconds) */
    startAt: z.number().int(),
    /** End time as Unix timestamp (seconds) */
    endAt: z.number().int().optional(),
    /** Whether this is an all-day event */
    allDay: z.boolean().default(false),
    /** IANA timezone identifier (e.g., 'America/New_York') */
    timezone: z.string().optional(),
    location: LocationSchema.optional(),
    /** URL for virtual attendance */
    virtualUrl: z.string().url().max(2048).optional(),
    /** RSVP deadline as Unix timestamp */
    rsvpDeadline: z.number().int().optional(),
    /** Maximum number of attendees */
    maxAttendees: z.number().int().gte(1).optional(),
    /** Who can see this event */
    visibility: z.enum(["group", "public", "private"]).default("group"),
    recurrence: RecurrenceRuleSchema.optional(),
    attachments: z.array(AttachmentSchema).max(10).optional(),
    /** Custom field values (requires custom-fields module) */
    customFields: z.record(z.string(), z.any()).optional(),
    /** Signal-style encrypted link previews for URLs in event description */
    linkPreviews: z.array(z.unknown()).max(10).optional(),
    /** Creator's public key (hex) */
    createdBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    /** Creation timestamp (Unix seconds) */
    createdAt: z.number().int(),
    /** Last update timestamp (Unix seconds) */
    updatedAt: z.number().int().optional(),
  })
  .passthrough();
export type Event = z.infer<typeof EventSchema>;

/** RSVP response to an event */
export const RSVPSchema = z
  .object({
    _v: z.string().regex(new RegExp("^\\d+\\.\\d+\\.\\d+$")),
    eventId: z.string().uuid(),
    pubkey: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
    status: z.enum(["going", "maybe", "not_going"]),
    /** Additional guests */
    guestCount: z.number().int().gte(0).default(0),
    note: z.string().max(500).optional(),
    respondedAt: z.number().int(),
  })
  .passthrough();
export type RSVP = z.infer<typeof RSVPSchema>;

/** Breakout room configuration for virtual events */
export const BreakoutRoomConfigSchema = z.object({
  _v: z.string().default("1.0.0"),
  enabled: z.boolean().optional(),
  autoAssign: z.boolean().optional(),
  roomCount: z.number().int().gte(2).optional(),
  roomNames: z.array(z.string()).optional(),
  allowSelfSelect: z.boolean().optional(),
  /** Duration in minutes */
  duration: z.number().int().optional(),
});
export type BreakoutRoomConfig = z.infer<typeof BreakoutRoomConfigSchema>;

/** Virtual event configuration for hybrid events */
export const EventVirtualConfigSchema = z
  .object({
    _v: z.string().default("1.0.0"),
    enabled: z.boolean(),
    conferenceRoomId: z.string().optional(),
    autoStartMinutes: z.number().int().gte(0).lte(60).default(15),
    waitingRoomEnabled: z.boolean().default(true),
    recordingEnabled: z.boolean().default(false),
    recordingConsentRequired: z.boolean().default(true),
    maxVirtualAttendees: z.number().int().gte(1).optional(),
    breakoutRoomsEnabled: z.boolean().default(false),
    breakoutConfig: BreakoutRoomConfigSchema.optional(),
    recordingUrl: z.string().url().optional(),
    e2eeRequired: z.boolean().default(true),
  })
  .passthrough();
export type EventVirtualConfig = z.infer<typeof EventVirtualConfigSchema>;

/** A volunteer role at an event */
export const EventVolunteerRoleSchema = z
  .object({
    _v: z.string().default("1.0.0"),
    id: z.string(),
    eventId: z.string(),
    name: z.string().max(100),
    description: z.string().optional(),
    spotsNeeded: z.number().int().gte(1),
    spotsFilled: z.number().int().gte(0),
    requiredTrainings: z.array(z.string()).optional(),
    shiftStart: z.number().int().optional(),
    shiftEnd: z.number().int().optional(),
    created: z.number().int(),
    createdBy: z.string(),
  })
  .passthrough();
export type EventVolunteerRole = z.infer<typeof EventVolunteerRoleSchema>;

/** A volunteer's signup for a specific role */
export const EventVolunteerSignupSchema = z
  .object({
    _v: z.string().default("1.0.0"),
    id: z.string(),
    eventId: z.string(),
    roleId: z.string(),
    contactId: z.string(),
    contactPubkey: z.string().optional(),
    status: z.enum(["pending", "confirmed", "declined", "no-show"]),
    signupTime: z.number().int(),
    confirmedBy: z.string().optional(),
    notes: z.string().optional(),
    created: z.number().int(),
    updated: z.number().int(),
  })
  .passthrough();
export type EventVolunteerSignup = z.infer<typeof EventVolunteerSignupSchema>;

/** Module version */
export const EVENTS_SCHEMA_VERSION = "1.0.0" as const;
