/**
 * @generated from protocol/schemas/modules/governance/v1.json
 * @version 1.0.0
 *
 * DO NOT EDIT - This file is auto-generated by tools/codegen
 * Zod validation schemas for the Governance module
 */

import { z } from "zod";

/** Type of proposal */
export const ProposalTypeSchema = z.enum([
  "general",
  "policy",
  "budget",
  "election",
  "amendment",
  "action",
  "resolution",
]);
export type ProposalType = z.infer<typeof ProposalTypeSchema>;

/** Current status of the proposal */
export const ProposalStatusSchema = z.enum([
  "draft",
  "discussion",
  "voting",
  "passed",
  "rejected",
  "expired",
  "withdrawn",
  "implemented",
]);
export type ProposalStatus = z.infer<typeof ProposalStatusSchema>;

/** Voting system to use */
export const VotingSystemSchema = z.enum([
  "simple-majority",
  "supermajority",
  "ranked-choice",
  "approval",
  "quadratic",
  "d-hondt",
  "consensus",
  "modified-consensus",
]);
export type VotingSystem = z.infer<typeof VotingSystemSchema>;

export const VoteOptionSchema = z.object({
  id: z.string().uuid(),
  /** Display label */
  label: z.string(),
  /** Option description */
  description: z.string().optional(),
  /** Display color */
  color: z.string().optional(),
  /** Display order */
  order: z.number().int().optional(),
});
export type VoteOption = z.infer<typeof VoteOptionSchema>;

export const QuorumRequirementSchema = z.object({
  /** Type of quorum */
  type: z.enum(["percentage", "absolute", "none"]),
  /** Quorum value (percentage 0-100 or absolute count) */
  value: z.number().gte(0).optional(),
  /** Whether abstentions count toward quorum */
  countAbstentions: z.boolean().default(true),
});
export type QuorumRequirement = z.infer<typeof QuorumRequirementSchema>;

export const PassingThresholdSchema = z.object({
  /** Type of threshold */
  type: z.enum(["simple-majority", "supermajority", "unanimous", "custom"]),
  /** Required percentage to pass */
  percentage: z.number().gte(0).lte(100).optional(),
});
export type PassingThreshold = z.infer<typeof PassingThresholdSchema>;

export const ProposalAttachmentSchema = z.object({
  type: z.enum(["file", "url", "document"]),
  name: z.string(),
  url: z.string().url().optional(),
  mimeType: z.string().optional(),
  size: z.number().int().optional(),
});
export type ProposalAttachment = z.infer<typeof ProposalAttachmentSchema>;

/** Configuration for quadratic voting on a proposal */
export const QuadraticVotingConfigSchema = z.object({
  /** Total token budget each voter receives to allocate across options */
  tokenBudget: z.number().int().gte(1),
  /** Maximum tokens a voter can allocate to a single option (defaults to tokenBudget) */
  maxTokensPerOption: z.number().int().gte(1).optional(),
});
export type QuadraticVotingConfig = z.infer<typeof QuadraticVotingConfigSchema>;

/** A proposal for group decision-making */
export const ProposalSchema = z.object({
  /** Schema version for graceful degradation */
  _v: z.string().default("1.0.0"),
  /** Unique identifier for the proposal */
  id: z.string().uuid(),
  /** Group this proposal belongs to */
  groupId: z.string().uuid(),
  /** Proposal title */
  title: z.string().min(1).max(200),
  /** Detailed proposal description (markdown supported) */
  description: z.string().optional(),
  type: ProposalTypeSchema,
  status: ProposalStatusSchema,
  votingSystem: VotingSystemSchema,
  /** Available voting options */
  options: z.array(VoteOptionSchema).min(2),
  quorum: QuorumRequirementSchema.optional(),
  threshold: PassingThresholdSchema.optional(),
  /** Discussion period before voting */
  discussionPeriod: z
    .object({ startsAt: z.number().int(), endsAt: z.number().int() })
    .optional(),
  /** Active voting period */
  votingPeriod: z.object({
    startsAt: z.number().int(),
    endsAt: z.number().int(),
  }),
  /** Allow abstention votes */
  allowAbstain: z.boolean().default(true),
  /** Whether votes are anonymous */
  anonymousVoting: z.boolean().default(false),
  /** Allow vote delegation */
  allowDelegation: z.boolean().default(false),
  /** Hex public key of creator */
  createdBy: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
  /** Unix timestamp of creation */
  createdAt: z.number().int(),
  /** Unix timestamp of last update */
  updatedAt: z.number().int().optional(),
  /** Supporting documents */
  attachments: z.array(ProposalAttachmentSchema).optional(),
  /** Categorization tags */
  tags: z.array(z.string()).optional(),
  /** Configuration for quadratic voting (required when votingSystem is 'quadratic') */
  quadraticConfig: QuadraticVotingConfigSchema.optional(),
  /** Custom field values */
  customFields: z.record(z.string(), z.any()).optional(),
});
export type Proposal = z.infer<typeof ProposalSchema>;

/** A quadratic voting ballot with token allocations across options */
export const QuadraticBallotSchema = z.object({
  /** Map of option ID to number of tokens allocated. Effective votes = sqrt(tokens). */
  allocations: z.record(z.string(), z.number().int().gte(0)),
  /** Total tokens used in this ballot (sum of all allocations, must not exceed budget) */
  totalTokens: z.number().int().gte(0),
});
export type QuadraticBallot = z.infer<typeof QuadraticBallotSchema>;

/** A vote cast on a proposal */
export const VoteSchema = z.object({
  _v: z.string().default("1.0.0"),
  id: z.string().uuid(),
  proposalId: z.string().uuid(),
  /** Voter's public key (may be encrypted for anonymous votes) */
  voterId: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
  /** Selected option(s) - single for simple, array for ranked-choice, QuadraticBallot for quadratic */
  choice: z.union([
    z.string().uuid(),
    z.array(z.string().uuid()),
    QuadraticBallotSchema,
  ]),
  /** Vote weight (for weighted voting) */
  weight: z.number().gte(0).default(1),
  /** Delegators whose votes this represents */
  delegatedFrom: z
    .array(z.string().regex(new RegExp("^[0-9a-f]{64}$")))
    .optional(),
  /** Optional vote comment */
  comment: z.string().max(1000).optional(),
  /** Unix timestamp when vote was cast */
  castAt: z.number().int(),
  /** Cryptographic signature of the vote */
  signature: z.string().optional(),
});
export type Vote = z.infer<typeof VoteSchema>;

/** Vote delegation from one member to another */
export const DelegationSchema = z.object({
  _v: z.string().default("1.0.0"),
  id: z.string().uuid(),
  /** Person delegating their vote */
  delegatorId: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
  /** Person receiving the delegation */
  delegateId: z.string().regex(new RegExp("^[0-9a-f]{64}$")),
  /** Scope of the delegation */
  scope: z.enum(["all", "category", "proposal"]),
  /** Categories for category-scoped delegation */
  categoryTags: z.array(z.string()).optional(),
  /** Specific proposal for proposal-scoped delegation */
  proposalId: z.string().uuid().optional(),
  validFrom: z.number().int().optional(),
  validUntil: z.number().int().optional(),
  revoked: z.boolean().default(false),
  createdAt: z.number().int(),
});
export type Delegation = z.infer<typeof DelegationSchema>;

/** Result for a single option in quadratic voting */
export const QuadraticOptionResultSchema = z.object({
  /** Total tokens allocated to this option across all voters */
  totalTokens: z.number().int().gte(0),
  /** Sum of sqrt(tokens) across all voters for this option */
  effectiveVotes: z.number().gte(0),
  /** Number of voters who allocated tokens to this option */
  voterCount: z.number().int().gte(0),
});
export type QuadraticOptionResult = z.infer<typeof QuadraticOptionResultSchema>;

/** Final result of a completed proposal */
export const ProposalResultSchema = z.object({
  _v: z.string().default("1.0.0"),
  proposalId: z.string().uuid(),
  outcome: z.enum(["passed", "rejected", "no-quorum", "tie", "expired"]),
  /** Winning option(s) */
  winningOptions: z.array(z.string().uuid()).optional(),
  /** Vote counts per option */
  voteCounts: z.record(z.string(), z.number()),
  totalVotes: z.number().int(),
  totalEligible: z.number().int().optional(),
  /** Participation percentage */
  participation: z.number().optional(),
  quorumMet: z.boolean().optional(),
  thresholdMet: z.boolean().optional(),
  /** Per-option quadratic voting results (only for quadratic voting proposals) */
  quadraticResults: z
    .record(z.string(), QuadraticOptionResultSchema)
    .optional(),
  calculatedAt: z.number().int(),
});
export type ProposalResult = z.infer<typeof ProposalResultSchema>;

/** Module version */
export const GOVERNANCE_SCHEMA_VERSION = "1.0.0" as const;
