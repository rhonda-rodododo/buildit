/**
 * @generated from protocol/schemas/modules/governance/v1.json
 * @version 1.0.0
 * @minReaderVersion 1.0.0
 *
 * DO NOT EDIT - This file is auto-generated by tools/codegen using quicktype
 */

// Version constants
export const GOVERNANCE_VERSION = "1.0.0";
export const GOVERNANCE_MIN_READER_VERSION = "1.0.0";

/**
 * A proposal for group decision-making
 */
export interface Proposal {
  /**
   * Schema version for graceful degradation
   */
  _v: string;
  /**
   * Allow abstention votes
   */
  allowAbstain?: boolean;
  /**
   * Allow vote delegation
   */
  allowDelegation?: boolean;
  /**
   * Whether votes are anonymous
   */
  anonymousVoting?: boolean;
  /**
   * Supporting documents
   */
  attachments?: ProposalAttachment[];
  /**
   * Unix timestamp of creation
   */
  createdAt: number;
  /**
   * Hex public key of creator
   */
  createdBy: string;
  /**
   * Custom field values
   */
  customFields?: { [key: string]: any };
  /**
   * Detailed proposal description (markdown supported)
   */
  description?: string;
  /**
   * Discussion period before voting
   */
  discussionPeriod?: DiscussionPeriod;
  /**
   * Group this proposal belongs to
   */
  groupId: string;
  /**
   * Unique identifier for the proposal
   */
  id: string;
  /**
   * Available voting options
   */
  options: VoteOption[];
  /**
   * Configuration for quadratic voting (required when votingSystem is 'quadratic')
   */
  quadraticConfig?: QuadraticConfigObject;
  quorum?: QuorumRequirement;
  status: ProposalStatus;
  /**
   * Categorization tags
   */
  tags?: string[];
  threshold?: PassingThreshold;
  /**
   * Proposal title
   */
  title: string;
  type: ProposalType;
  /**
   * Unix timestamp of last update
   */
  updatedAt?: number;
  /**
   * Active voting period
   */
  votingPeriod: VotingPeriod;
  votingSystem: VotingSystem;
  [property: string]: any;
}

export enum AttachmentType {
  Document = "document",
  File = "file",
  URL = "url",
}

/**
 * Discussion period before voting
 */
export interface DiscussionPeriod {
  endsAt: number;
  startsAt: number;
  [property: string]: any;
}

/**
 * Configuration for quadratic voting (required when votingSystem is 'quadratic')
 *
 * Configuration for quadratic voting on a proposal
 */
export interface QuadraticConfigObject {
  /**
   * Maximum tokens a voter can allocate to a single option (defaults to tokenBudget)
   */
  maxTokensPerOption?: number;
  /**
   * Total token budget each voter receives to allocate across options
   */
  tokenBudget: number;
  [property: string]: any;
}

/**
 * Type of quorum
 */
export enum QuorumType {
  Absolute = "absolute",
  None = "none",
  Percentage = "percentage",
}

/**
 * Current status of the proposal
 */
export enum ProposalStatus {
  Discussion = "discussion",
  Draft = "draft",
  Expired = "expired",
  Implemented = "implemented",
  Passed = "passed",
  Rejected = "rejected",
  Voting = "voting",
  Withdrawn = "withdrawn",
}

/**
 * Type of threshold
 */
export enum ThresholdType {
  Custom = "custom",
  SimpleMajority = "simple-majority",
  Supermajority = "supermajority",
  Unanimous = "unanimous",
}

/**
 * Type of proposal
 */
export enum ProposalType {
  Action = "action",
  Amendment = "amendment",
  Budget = "budget",
  Election = "election",
  General = "general",
  Policy = "policy",
  Resolution = "resolution",
}

/**
 * Active voting period
 */
export interface VotingPeriod {
  endsAt: number;
  startsAt: number;
  [property: string]: any;
}

/**
 * Voting system to use
 */
export enum VotingSystem {
  Approval = "approval",
  Consensus = "consensus",
  DHondt = "d-hondt",
  ModifiedConsensus = "modified-consensus",
  Quadratic = "quadratic",
  RankedChoice = "ranked-choice",
  SimpleMajority = "simple-majority",
  Supermajority = "supermajority",
}

export interface VoteOption {
  /**
   * Display color
   */
  color?: string;
  /**
   * Option description
   */
  description?: string;
  id: string;
  /**
   * Display label
   */
  label: string;
  /**
   * Display order
   */
  order?: number;
  [property: string]: any;
}

export interface QuorumRequirement {
  /**
   * Whether abstentions count toward quorum
   */
  countAbstentions?: boolean;
  /**
   * Type of quorum
   */
  type: QuorumType;
  /**
   * Quorum value (percentage 0-100 or absolute count)
   */
  value?: number;
  [property: string]: any;
}

export interface PassingThreshold {
  /**
   * Required percentage to pass
   */
  percentage?: number;
  /**
   * Type of threshold
   */
  type: ThresholdType;
  [property: string]: any;
}

/**
 * A vote cast on a proposal
 */
export interface Vote {
  _v: string;
  /**
   * Unix timestamp when vote was cast
   */
  castAt: number;
  /**
   * Selected option(s) - single for simple, array for ranked-choice, QuadraticBallot for
   * quadratic
   */
  choice: string[] | QuadraticBallotObject | string;
  /**
   * Optional vote comment
   */
  comment?: string;
  /**
   * Delegators whose votes this represents
   */
  delegatedFrom?: string[];
  id: string;
  proposalId: string;
  /**
   * Cryptographic signature of the vote
   */
  signature?: string;
  /**
   * Voter's public key (may be encrypted for anonymous votes)
   */
  voterId: string;
  /**
   * Vote weight (for weighted voting)
   */
  weight?: number;
  [property: string]: any;
}

/**
 * A quadratic voting ballot with token allocations across options
 */
export interface QuadraticBallotObject {
  /**
   * Map of option ID to number of tokens allocated. Effective votes = sqrt(tokens).
   */
  allocations: { [key: string]: number };
  /**
   * Total tokens used in this ballot (sum of all allocations, must not exceed budget)
   */
  totalTokens: number;
  [property: string]: any;
}

/**
 * Vote delegation from one member to another
 */
export interface Delegation {
  _v: string;
  /**
   * Categories for category-scoped delegation
   */
  categoryTags?: string[];
  createdAt: number;
  /**
   * Person receiving the delegation
   */
  delegateId: string;
  /**
   * Person delegating their vote
   */
  delegatorId: string;
  id: string;
  /**
   * Specific proposal for proposal-scoped delegation
   */
  proposalId?: string;
  revoked?: boolean;
  /**
   * Scope of the delegation
   */
  scope: Scope;
  validFrom?: number;
  validUntil?: number;
  [property: string]: any;
}

/**
 * Scope of the delegation
 */
export enum Scope {
  All = "all",
  Category = "category",
  Proposal = "proposal",
}

/**
 * Configuration for quadratic voting on a proposal
 */
export interface QuadraticVotingConfig {
  /**
   * Maximum tokens a voter can allocate to a single option (defaults to tokenBudget)
   */
  maxTokensPerOption?: number;
  /**
   * Total token budget each voter receives to allocate across options
   */
  tokenBudget: number;
  [property: string]: any;
}

/**
 * A quadratic voting ballot with token allocations across options
 */
export interface QuadraticBallot {
  /**
   * Map of option ID to number of tokens allocated. Effective votes = sqrt(tokens).
   */
  allocations: { [key: string]: number };
  /**
   * Total tokens used in this ballot (sum of all allocations, must not exceed budget)
   */
  totalTokens: number;
  [property: string]: any;
}

/**
 * Result for a single option in quadratic voting
 */
export interface QuadraticOptionResult {
  /**
   * Sum of sqrt(tokens) across all voters for this option
   */
  effectiveVotes: number;
  /**
   * Total tokens allocated to this option across all voters
   */
  totalTokens: number;
  /**
   * Number of voters who allocated tokens to this option
   */
  voterCount: number;
  [property: string]: any;
}

export interface ProposalAttachment {
  mimeType?: string;
  name: string;
  size?: number;
  type: AttachmentType;
  url?: string;
  [property: string]: any;
}

/**
 * Final result of a completed proposal
 */
export interface ProposalResult {
  _v: string;
  calculatedAt: number;
  outcome: Outcome;
  /**
   * Participation percentage
   */
  participation?: number;
  proposalId: string;
  /**
   * Per-option quadratic voting results (only for quadratic voting proposals)
   */
  quadraticResults?: { [key: string]: QuadraticResultValue };
  quorumMet?: boolean;
  thresholdMet?: boolean;
  totalEligible?: number;
  totalVotes: number;
  /**
   * Vote counts per option
   */
  voteCounts: { [key: string]: number };
  /**
   * Winning option(s)
   */
  winningOptions?: string[];
  [property: string]: any;
}

export enum Outcome {
  Expired = "expired",
  NoQuorum = "no-quorum",
  Passed = "passed",
  Rejected = "rejected",
  Tie = "tie",
}

/**
 * Result for a single option in quadratic voting
 */
export interface QuadraticResultValue {
  /**
   * Sum of sqrt(tokens) across all voters for this option
   */
  effectiveVotes: number;
  /**
   * Total tokens allocated to this option across all voters
   */
  totalTokens: number;
  /**
   * Number of voters who allocated tokens to this option
   */
  voterCount: number;
  [property: string]: any;
}
