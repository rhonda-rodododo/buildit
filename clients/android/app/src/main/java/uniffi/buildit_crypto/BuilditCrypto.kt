// This file will be replaced by UniFFI-generated code when running scripts/build-crypto.sh
// For now, this provides a stub interface that matches the UDL specification

package uniffi.buildit_crypto

/**
 * BuildIt Crypto FFI bindings.
 *
 * This object provides access to the native Rust cryptographic library via JNI.
 * The actual implementation is generated by UniFFI from buildit_crypto.udl.
 *
 * To regenerate:
 *   ./scripts/build-crypto.sh bindings
 */
object BuilditCrypto {

    private var isLoaded = false

    /**
     * Load the native library.
     */
    @Synchronized
    fun ensureLoaded() {
        if (!isLoaded) {
            System.loadLibrary("buildit_crypto")
            isLoaded = true
        }
    }

    // ============== Key Derivation ==============

    /**
     * Derive a master key from password and salt using PBKDF2.
     * Uses 600,000 iterations as per BuildIt protocol spec.
     */
    @Throws(CryptoException::class)
    external fun deriveMasterKey(password: String, salt: ByteArray): ByteArray

    /**
     * Derive a database encryption key from the master key using HKDF.
     */
    @Throws(CryptoException::class)
    external fun deriveDatabaseKey(masterKey: ByteArray): ByteArray

    /**
     * Derive a conversation key for NIP-44 encryption.
     */
    @Throws(CryptoException::class)
    external fun deriveConversationKey(privateKey: ByteArray, recipientPubkey: String): ByteArray

    // ============== Key Generation ==============

    /**
     * Generate a new secp256k1 key pair.
     */
    external fun generateKeypair(): KeyPair

    /**
     * Get the public key from a private key.
     */
    @Throws(CryptoException::class)
    external fun getPublicKey(privateKey: ByteArray): String

    // ============== NIP-44 Encryption ==============

    /**
     * Encrypt a message using NIP-44 (ChaCha20-Poly1305).
     */
    @Throws(CryptoException::class)
    external fun nip44Encrypt(privateKey: ByteArray, recipientPubkey: String, plaintext: String): String

    /**
     * Decrypt a message using NIP-44.
     */
    @Throws(CryptoException::class)
    external fun nip44Decrypt(privateKey: ByteArray, senderPubkey: String, ciphertext: String): String

    // ============== NIP-17 Gift Wrap ==============

    /**
     * Create a rumor (unsigned event) for NIP-17.
     */
    @Throws(CryptoException::class)
    external fun createRumor(
        senderPubkey: String,
        recipientPubkey: String,
        content: String,
        createdAt: Long
    ): NostrEvent

    /**
     * Create a seal (encrypted rumor) for NIP-17.
     */
    @Throws(CryptoException::class)
    external fun createSeal(
        senderPrivateKey: ByteArray,
        recipientPubkey: String,
        rumor: NostrEvent,
        createdAt: Long
    ): NostrEvent

    /**
     * Create a gift wrap (sealed message with ephemeral key) for NIP-17.
     */
    @Throws(CryptoException::class)
    external fun createGiftWrap(
        recipientPubkey: String,
        seal: NostrEvent,
        createdAt: Long
    ): NostrEvent

    /**
     * Unwrap a gift-wrapped message.
     */
    @Throws(CryptoException::class)
    external fun unwrapGiftWrap(
        recipientPrivateKey: ByteArray,
        giftWrap: NostrEvent
    ): UnwrapResult

    // ============== Nostr Events ==============

    /**
     * Sign a Nostr event.
     */
    @Throws(CryptoException::class)
    external fun signEvent(privateKey: ByteArray, event: UnsignedEvent): NostrEvent

    /**
     * Verify a Nostr event signature.
     */
    external fun verifyEvent(event: NostrEvent): Boolean

    /**
     * Compute the ID for an unsigned event.
     */
    @Throws(CryptoException::class)
    external fun computeEventId(event: UnsignedEvent): String

    // ============== AES-GCM ==============

    /**
     * Encrypt data using AES-256-GCM.
     */
    @Throws(CryptoException::class)
    external fun aesEncrypt(key: ByteArray, plaintext: ByteArray): EncryptedData

    /**
     * Decrypt data using AES-256-GCM.
     */
    @Throws(CryptoException::class)
    external fun aesDecrypt(key: ByteArray, encrypted: EncryptedData): ByteArray

    // ============== Utilities ==============

    /**
     * Generate a random salt.
     */
    external fun generateSalt(length: Int): ByteArray

    /**
     * Convert bytes to hex string.
     */
    external fun bytesToHex(bytes: ByteArray): String

    /**
     * Convert hex string to bytes.
     */
    @Throws(CryptoException::class)
    external fun hexToBytes(hexString: String): ByteArray

    /**
     * Randomize a timestamp within a range (for metadata protection).
     */
    external fun randomizeTimestamp(timestamp: Long, rangeSeconds: Int): Long
}

// ============== Data Classes ==============

/**
 * A key pair consisting of private and public keys.
 */
data class KeyPair(
    val privateKey: ByteArray,
    val publicKey: String
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false
        other as KeyPair
        return privateKey.contentEquals(other.privateKey) && publicKey == other.publicKey
    }

    override fun hashCode(): Int {
        var result = privateKey.contentHashCode()
        result = 31 * result + publicKey.hashCode()
        return result
    }
}

/**
 * An unsigned Nostr event (before signing).
 */
data class UnsignedEvent(
    val pubkey: String,
    val createdAt: Long,
    val kind: Int,
    val tags: List<List<String>>,
    val content: String
)

/**
 * A signed Nostr event.
 */
data class NostrEvent(
    val id: String,
    val pubkey: String,
    val createdAt: Long,
    val kind: Int,
    val tags: List<List<String>>,
    val content: String,
    val sig: String
)

/**
 * Result of unwrapping a gift-wrapped message.
 */
data class UnwrapResult(
    val rumor: NostrEvent,
    val senderPubkey: String,
    val sealVerified: Boolean
)

/**
 * Encrypted data with nonce/IV.
 */
data class EncryptedData(
    val ciphertext: ByteArray,
    val nonce: ByteArray
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false
        other as EncryptedData
        return ciphertext.contentEquals(other.ciphertext) && nonce.contentEquals(other.nonce)
    }

    override fun hashCode(): Int {
        var result = ciphertext.contentHashCode()
        result = 31 * result + nonce.contentHashCode()
        return result
    }
}

/**
 * Exception thrown by cryptographic operations.
 */
class CryptoException(
    val errorType: CryptoError,
    message: String? = null
) : Exception(message ?: errorType.name)

/**
 * Types of cryptographic errors.
 */
enum class CryptoError {
    InvalidKey,
    InvalidPublicKey,
    InvalidSignature,
    EncryptionFailed,
    DecryptionFailed,
    InvalidPlaintextLength,
    InvalidCiphertext,
    InvalidPadding,
    InvalidMac,
    InvalidHex,
    InvalidJson,
    SigningFailed,
    KeyDerivationFailed,
    RandomGenerationFailed
}
